{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IA Generativa en Acci\u00f3n: Spring AI con OpenAI, Java 21 y Vaadin","text":""},{"location":"#descripcion-del-taller","title":"Descripci\u00f3n del Taller","text":"<p>En este taller interactivo, aprender\u00e1s paso a paso c\u00f3mo trabajar con la IA Generativa desde cero usando Spring AI con OpenAI, Java 21 y Vaadin. Exploraremos el proceso de generaci\u00f3n de textos, im\u00e1genes y audios en una aplicaci\u00f3n frontend construida con Vaadin. Este taller est\u00e1 dise\u00f1ado para aquellos que buscan dominar las herramientas de Spring AI y Vaadin y quieren integrar inteligencia artificial en aplicaciones modernas. Al final del taller, tendr\u00e1s una aplicaci\u00f3n funcional y un conocimiento pr\u00e1ctico de c\u00f3mo utilizar modelos de lenguaje de gran tama\u00f1o (LLM) en un entorno de producci\u00f3n.</p>"},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>La inteligencia artificial generativa est\u00e1 transformando la manera en que interactuamos con la tecnolog\u00eda. En este taller, exploraremos el potencial de Spring AI y OpenAI junto con Java 21 y Vaadin para crear una aplicaci\u00f3n que aproveche los modelos de lenguaje de gran tama\u00f1o (LLM) para la generaci\u00f3n de textos, im\u00e1genes y audios. Este taller es ideal para aquellos interesados en aprender a integrar IA generativa en aplicaciones web y dominar el uso de Spring AI para construir aplicaciones modernas, interactivas y enriquecidas con funcionalidades de IA.</p>"},{"location":"#requisitos","title":"Requisitos","text":"<ul> <li>Java: Versi\u00f3n 21.</li> <li>Spring Boot: Versi\u00f3n 3.2.x o superior.</li> <li>Base de Datos: PostgreSQL.</li> <li>IDE (Entorno de Desarrollo Integrado): IntelliJ IDEA, Eclipse, o cualquier otro de tu preferencia.</li> <li>Herramientas de Construcci\u00f3n: Maven o Gradle.</li> <li>Docker: Utilizado para la creaci\u00f3n y gesti\u00f3n de contenedores, facilitando un entorno de desarrollo consistente y f\u00e1cil de replicar.</li> </ul>"},{"location":"#diagrama-de-la-aplicacion","title":"Diagrama de la Aplicaci\u00f3n","text":""},{"location":"#descripcion-del-diagrama-de-la-aplicacion","title":"Descripci\u00f3n del Diagrama de la Aplicaci\u00f3n","text":"<p>El diagrama muestra una vista general de la arquitectura t\u00e9cnica y el flujo de comunicaci\u00f3n entre los componentes en la aplicaci\u00f3n de IA generativa:</p> <ol> <li> <p>Usuario: El usuario env\u00eda una solicitud o \"prompt\" a la aplicaci\u00f3n a trav\u00e9s de una interfaz frontend desarrollada con Vaadin. La solicitud puede ser para generar texto, im\u00e1genes o audios.</p> </li> <li> <p>Aplicaci\u00f3n Spring: Esta es la capa backend construida en Spring Boot y contiene el componente Spring AI ChatClient. Este componente act\u00faa como el intermediario entre la aplicaci\u00f3n y los servicios de IA. Su principal tarea es recibir el prompt del usuario, procesarlo, y luego comunicarse con un proveedor de IA para obtener la respuesta generada.</p> </li> <li> <p>Spring AI ChatClient: Este componente dentro de la aplicaci\u00f3n Spring se encarga de construir la solicitud y enviar el prompt al proveedor de IA (como OpenAI). Tambi\u00e9n maneja la respuesta generada por el proveedor de IA y la env\u00eda de vuelta a la interfaz de usuario.</p> </li> <li> <p>Proveedor de IA (AI Provider): Este es el servicio externo (por ejemplo, OpenAI, Google, MistralAI, etc.) que contiene el LLM (Large Language Model). Recibe el prompt desde el Spring AI ChatClient, genera el contenido solicitado (texto, im\u00e1genes o audios) y lo devuelve a la aplicaci\u00f3n Spring.</p> </li> <li> <p>LLM (Large Language Model): Es el modelo de IA generativa que procesa el prompt y produce una respuesta. Dependiendo del tipo de solicitud, el LLM puede generar contenido de diferentes formatos y complejidades.</p> </li> </ol>"},{"location":"chat-model-calling/","title":"Funcion Calling","text":""},{"location":"chat-model-calling/#descripcion","title":"Descripci\u00f3n","text":"<p>La Function Calling en OpenAI y Spring AI permite que el modelo de IA no solo genere respuestas en texto, sino que tambi\u00e9n invoque funciones espec\u00edficas del backend para obtener informaci\u00f3n precisa y estructurada. Esto transforma el modelo de IA en un intermediario inteligente que puede interactuar con bases de datos o servicios externos y devolver resultados espec\u00edficos seg\u00fan la solicitud del usuario.</p> <p>A diferencia del modelo de chat b\u00e1sico, donde las respuestas son generadas \u00fanicamente por el modelo de IA basado en el contexto de la conversaci\u00f3n, Function Calling permite conectar el modelo con funcionalidades espec\u00edficas (como buscar informaci\u00f3n de un libro en una base de datos). Esto ofrece resultados m\u00e1s precisos y controlados, garantizando que las respuestas sean coherentes y actualizadas, y ampliando las capacidades de la IA para integrarse con aplicaciones empresariales.</p>"},{"location":"chat-model-calling/#paso-1-controlador-functioncallingcontroller","title":"Paso 1: Controlador FunctionCallingController","text":"<p>El controlador <code>FunctionCallingController</code> define el endpoint para obtener la informaci\u00f3n de un libro utilizando el modelo de chat de OpenAI.</p> FunctionCallingController.java<pre><code>@RestController\n@RequestMapping(\"/functions\")\n@RequiredArgsConstructor\npublic class FunctionCallingController {\n    private final OpenAiChatModel openAiChatModel;\n\n    @GetMapping(\"/book\")\n    public ResponseEntity&lt;String&gt; getBookInfo(@RequestParam(\"bookName\") String bookName) {\n        UserMessage userMessage = new UserMessage(\"\u00bfCual es la informaci\u00f3n de este libro \" + bookName + \"?\");\n\n        ChatResponse response = openAiChatModel.call(new Prompt(List.of(userMessage),\n                OpenAiChatOptions.builder().withFunction(\"BookInfo\").build()\n        ));\n\n        String result = response.getResult().getOutput().getContent();\n\n        return ResponseEntity.ok(result);\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>@GetMapping(\"/book\")</code>: Define el endpoint <code>/functions/book</code> que recibe el nombre de un libro como par\u00e1metro de consulta (<code>bookName</code>).</li> <li>L\u00ednea 1 <code>UserMessage</code>: Crea un mensaje de usuario preguntando sobre la informaci\u00f3n del libro especificado.</li> <li>L\u00ednea 1 <code>OpenAiChatOptions</code>: Usa la opci\u00f3n <code>withFunction(\"BookInfo\")</code> para indicar que queremos que el modelo llame a la funci\u00f3n <code>BookInfo</code> para obtener los datos del libro.</li> <li>L\u00ednea 1 <code>response.getResult().getOutput().getContent()</code>: Extrae la respuesta generada por la IA y la devuelve al cliente.</li> </ul>"},{"location":"chat-model-calling/#paso-2-configuracion-de-funciones-functionconfig","title":"Paso 2: Configuraci\u00f3n de Funciones (<code>FunctionConfig</code>)","text":"<p>La clase <code>FunctionConfig</code> configura las funciones disponibles en el modelo de IA. Define las funciones <code>weatherFunctionInfo</code> y <code>bookInfoFunction</code>.</p> FunctionConfig.java<pre><code>@Configuration\npublic class FunctionConfig {\n\n    @Bean\n    public FunctionCallback weatherFunctionInfo() {\n        return FunctionCallbackWrapper.builder(new MockWeatherService())\n                .withName(\"weatherFunction\")\n                .withDescription(\"Get the weather in location\")\n                .withResponseConverter(response -&gt; \"\" + response.temp() + response.unit())\n                .build();\n    }\n\n    @Bean\n    public FunctionCallback bookInfoFunction(IBookRepo repo) {\n        return FunctionCallbackWrapper.builder(new BookFunctionServiceImpl(repo))\n                .withName(\"BookInfo\")\n                .withDescription(\"Get book info from book name\")\n                .withResponseConverter(response -&gt; \"\" + response.books())\n                .build();\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>weatherFunctionInfo</code>: Configura una funci\u00f3n ficticia para obtener informaci\u00f3n del clima. (En este ejemplo no la usaremos en el formulario).</li> <li>L\u00ednea 1 <code>bookInfoFunction</code>:<ul> <li><code>FunctionCallbackWrapper.builder(new BookFunctionServiceImpl(repo))</code>: Crea una funci\u00f3n que obtiene informaci\u00f3n de un libro desde el repositorio de libros.</li> <li><code>withName(\"BookInfo\")</code>: Define el nombre de la funci\u00f3n como BookInfo, que se utiliza en el controlador para obtener detalles del libro.</li> <li><code>withResponseConverter(...)</code>: Configura un convertidor de respuesta para mostrar los detalles del libro de una manera espec\u00edfica.</li> </ul> </li> </ul>"},{"location":"chat-model-calling/#paso-3-prueba-en-postman","title":"Paso 3: Prueba en Postman","text":"<p>Para verificar que el endpoint funcione correctamente, realizamos una prueba en Postman, como se puede observar en la figura #3:</p> <p></p> <p>Figura #3: Prueba del Endpoint <code>/functions/book</code> con Postman</p> <ul> <li>Endpoint: <code>GET http://localhost:8080/functions/book?bookName=Volc\u00e1n de la IA</code></li> <li>Respuesta: El servidor responde con informaci\u00f3n detallada del libro en formato de texto (como se muestra en la captura de pantalla). Incluye detalles como el nombre del autor, pa\u00eds, foto del autor, y portada del libro.</li> </ul>"},{"location":"chat-model-calling/#paso-4-integracion-en-vaadin-functioncallingview","title":"Paso 4: Integraci\u00f3n en Vaadin (FunctionCallingView)","text":"<p>Ahora integramos la funcionalidad en Vaadin para que los usuarios puedan consultar la informaci\u00f3n del libro desde la interfaz web.</p> FunctionConfig.java<pre><code>@Route(\"book-info\")\n@Menu(title = \"FunctionCallingView\", order = 2)\npublic class FunctionCallingView extends VerticalLayout {\n    private final RestTemplate restTemplate = new RestTemplate();\n    private final String backendUrl = \"http://localhost:8080/functions/book\";\n\n    public FunctionCallingView() {\n        setSizeFull();\n\n        // Campo de texto para ingresar el nombre del libro\n        TextField bookNameInput = new TextField(\"Enter the book name:\");\n        bookNameInput.setWidth(\"400px\");\n\n        // Bot\u00f3n de env\u00edo\n        Button sendButton = new Button(\"Get Book Info\");\n        Button clearButton = new Button(\"Clear\");\n\n        // \u00c1rea de texto para mostrar la respuesta\n        TextArea resultArea = new TextArea(\"Book Information:\");\n        resultArea.setWidth(\"600px\");\n        resultArea.setHeight(\"300px\");\n        resultArea.setReadOnly(true); // Solo lectura para mostrar la respuesta\n\n        HorizontalLayout buttonLayout = new HorizontalLayout(sendButton, clearButton);\n\n        sendButton.addClickListener(click -&gt; {\n            String bookName = bookNameInput.getValue();\n\n            // Construye la URL con el par\u00e1metro del libro\n            String url = backendUrl + \"?bookName=\" + bookName;\n\n            // Llama al backend para obtener la informaci\u00f3n del libro\n            ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(url, String.class);\n\n            if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {\n                resultArea.setValue(responseEntity.getBody());  // Muestra la respuesta en el \u00e1rea de texto\n            } else {\n                resultArea.setValue(\"Error: Failed to get book information.\");\n            }\n        });\n\n        // Bot\u00f3n para limpiar el \u00e1rea de respuesta\n        clearButton.addClickListener(click -&gt; {\n            resultArea.clear();\n            bookNameInput.clear();\n        });\n\n        add(bookNameInput, buttonLayout, resultArea);\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>@Route(\"book-info\")</code>: Define la ruta de esta vista como /book-info.</li> <li>L\u00ednea 11 <code>TextField bookNameInput</code>: Campo de texto donde el usuario ingresa el nombre del libro que desea consultar.</li> <li>L\u00ednea 15 <code>Button sendButton</code>: Bot\u00f3n para enviar la solicitud al backend.</li> <li>L\u00ednea 16 <code>Button clearButton</code>: Bot\u00f3n para limpiar la entrada y el \u00e1rea de resultados.</li> <li>L\u00ednea 19 <code>TextArea resultArea</code>: \u00c1rea de texto en solo lectura para mostrar la informaci\u00f3n del libro.</li> <li>L\u00f3gica del Bot\u00f3n <code>sendButton</code>:<ul> <li>Construye la URL de la solicitud con el nombre del libro como par\u00e1metro (<code>bookName</code>).</li> <li>Llama al backend utilizando <code>restTemplate</code> y muestra la respuesta en <code>resultArea</code>.</li> <li>Si la solicitud falla, muestra un mensaje de error.</li> </ul> </li> <li>L\u00f3gica del Bot\u00f3n <code>clearButton</code>: Limpia el campo de entrada y el \u00e1rea de resultados, permitiendo una nueva consulta.</li> </ul>"},{"location":"chat-model-calling/#visualizacion-del-formulario","title":"Visualizaci\u00f3n del Formulario","text":"<p>Como se muestrar en la Figura #4, asi luce la interfaz de <code>FunctionCallingView</code> en Vaadin:</p> <p> Figura #4: Formulario Function Calling</p> <ul> <li>Campo de Texto: El usuario ingresa el nombre del libro (\"Volc\u00e1n de la IA\").</li> <li>Bot\u00f3n \"Get Book Info\": Env\u00eda la solicitud al backend para obtener la informaci\u00f3n del libro.</li> <li>\u00c1rea de Resultados: Muestra la informaci\u00f3n del libro en un cuadro de texto. En el ejemplo, se detalla que el libro \"Volc\u00e1n de la IA\" es una obra ficticia creada para un workshop, junto con el autor y enlaces a im\u00e1genes.</li> </ul>"},{"location":"chat-model/","title":"Chat Model","text":""},{"location":"chat-model/#paso-1-configuracion-de-la-clave-api-de-openai","title":"Paso 1: Configuraci\u00f3n de la Clave API de OpenAI","text":"<p>Para que nuestra aplicaci\u00f3n pueda acceder a los modelos de OpenAI, necesitamos una clave API v\u00e1lida de OpenAI. Esta clave permite autenticar las solicitudes y garantiza que la aplicaci\u00f3n tenga permiso para utilizar los modelos de lenguaje. Aseg\u00farate de tener una cuenta en OpenAI y de obtener una clave API desde su sitio web.</p> <p>Una vez tengas la clave, debes configurarla en el archivo <code>application.yml</code> para que est\u00e9 disponible en el proyecto. La configuraci\u00f3n deber\u00eda verse as\u00ed:</p> Application.yml<pre><code>spring:\n  ai:\n    openai:\n      api-key: `SPRING_AI_OPENAI_API_KEY`\n</code></pre> <ul> <li>Nota: Reemplaza <code>SPRING_AI_OPENAI_API_KEY</code> con tu clave API real de OpenAI.</li> </ul> <p>Esta configuraci\u00f3n permitir\u00e1 que nuestra aplicaci\u00f3n Spring Boot acceda a la clave a trav\u00e9s de la anotaci\u00f3n <code>@Value</code> en la clase de configuraci\u00f3n <code>OpenAIConfig</code>.</p>"},{"location":"chat-model/#paso-2-clase-de-configuracion-openaiconfig","title":"Paso 2: Clase de Configuraci\u00f3n <code>OpenAIConfig</code>","text":"<p>Para crear una instancia de OpenAiChatModel (la clase que interact\u00faa con los modelos de OpenAI), necesitamos una clase de configuraci\u00f3n que inyecte la clave API y configure los par\u00e1metros b\u00e1sicos para las solicitudes de generaci\u00f3n de texto. Esta clase es <code>OpenAIConfig</code>.</p> OpenAIConfig.java<pre><code>@Configuration\npublic class OpenAIConfig {\n\n    @Value(\"${spring.ai.openai.api-key}\")\n    private String API_KEY;\n\n    @Bean\n    public OpenAiChatModel openAiChatModel() {\n        final OpenAiApi openAiApi = new OpenAiApi(API_KEY);\n\n        return new OpenAiChatModel(openAiApi, OpenAiChatOptions.builder()\n                .withModel(\"gpt-3.5-turbo\")\n                .withTemperature(0.8)\n                .withMaxTokens(200)\n                .build()\n        );\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1: <code>@Configuration</code> Anota la clase para que Spring la reconozca como una clase de configuraci\u00f3n. Esto significa que Spring gestionar\u00e1 los beans definidos dentro de esta clase.</p> </li> <li> <p>L\u00ednea 4: <code>@Value(\"${spring.ai.openai.api-key}\")</code> Inyecta el valor de la clave API de OpenAI desde el archivo application.yml. Esta clave es necesaria para autenticar las solicitudes al servicio de OpenAI.</p> </li> <li> <p>L\u00ednea 8: <code>M\u00e9todo openAiChatModel()</code> Este m\u00e9todo define un bean de tipo <code>OpenAiChatModel</code>, que es el cliente que utilizaremos para enviar solicitudes a OpenAI.</p> </li> <li> <p>L\u00ednea 9: <code>OpenAiApi</code> Se inicializa con la clave API, permitiendo la comunicaci\u00f3n segura con OpenAI.</p> </li> <li>L\u00ednea 11: <code>OpenAiChatModel</code> Esta instancia se configura con <code>OpenAiChatOptions</code> para definir par\u00e1metros espec\u00edficos como:</li> <li>L\u00ednea 12: <code>withModel(\"gpt-3.5-turbo\")</code> Especifica el modelo que utilizaremos, en este caso, gpt-3.5-turbo.</li> <li>L\u00ednea 13: <code>withTemperature(0.8)</code> Controla la creatividad de las respuestas generadas. Valores m\u00e1s bajos hacen las respuestas m\u00e1s conservadoras, mientras que valores m\u00e1s altos (hasta 1) hacen las respuestas m\u00e1s creativas.</li> <li>L\u00ednea 14: <code>withMaxTokens(200)</code> Define el l\u00edmite de tokens (unidades de texto) en la respuesta. Esto evita que las respuestas sean demasiado largas y controla el costo de las solicitudes.</li> <li>L\u00ednea 15: <code>build()</code>: Este m\u00e9todo se utiliza para finalizar la construcci\u00f3n de OpenAiChatOptions y devuelve una instancia configurada de estas opciones. Sin build(), la configuraci\u00f3n del cliente quedar\u00eda incompleta y lanzar\u00eda un error.</li> </ul> <p>Este bean estar\u00e1 disponible para ser inyectado en otras clases, como el controlador <code>ChatController</code>, permiti\u00e9ndonos realizar llamadas a la API de OpenAI.</p>"},{"location":"chat-model/#paso-3-clase-responsedto","title":"Paso 3: Clase <code>ResponseDTO</code>","text":"<p>La clase <code>ResponseDTO</code> es un Data Transfer Object (DTO) que permite estructurar las respuestas enviadas desde los endpoints en el controlador. Este patr\u00f3n es \u00fatil para mantener consistencia en las respuestas, asegurando que cada respuesta contenga un estado, un mensaje y los datos espec\u00edficos.</p> ChatController.java<pre><code>@AllArgsConstructor\n@NoArgsConstructor\n@Getter\n@Setter\npublic class ResponseDTO&lt;T&gt; {\n    private int status;\n    private String message;\n    private T data;\n}\n</code></pre>"},{"location":"chat-model/#anotaciones-y-propiedades","title":"Anotaciones y Propiedades","text":"<ul> <li> <p><code>@AllArgsConstructor</code>: Genera un constructor que acepta valores para todos los atributos (<code>status</code>, <code>message</code>, y <code>data</code>), lo cual facilita la creaci\u00f3n de instancias con todos los campos inicializados.</p> </li> <li> <p><code>@NoArgsConstructor</code>: Genera un constructor sin argumentos, permitiendo la creaci\u00f3n de instancias vac\u00edas de <code>ResponseDTO</code>.</p> </li> <li> <p><code>@Getter</code> y <code>@Setter</code>: Estas anotaciones de Lombok generan autom\u00e1ticamente los m\u00e9todos <code>get</code> y <code>set</code> para cada propiedad, simplificando el acceso y modificaci\u00f3n de los atributos sin necesidad de escribirlos manualmente.</p> </li> </ul>"},{"location":"chat-model/#propiedades","title":"Propiedades","text":"<ul> <li> <p><code>status</code> (<code>int</code>): Representa el c\u00f3digo de estado de la respuesta (por ejemplo, <code>200</code> para \u00e9xito, <code>400</code> para errores de cliente, etc.). Esto facilita la interpretaci\u00f3n del estado de la solicitud en el cliente.</p> </li> <li> <p><code>message</code> (<code>String</code>): Proporciona un mensaje descriptivo sobre el resultado de la solicitud. Este mensaje puede ser \"success\", \"error\", u otra descripci\u00f3n, y ayuda al cliente a entender mejor el contexto de la respuesta.</p> </li> <li> <p><code>data</code> (<code>T</code>): Representa los datos espec\u00edficos devueltos por el endpoint. Esta es una propiedad gen\u00e9rica (<code>&lt;T&gt;</code>), lo que significa que puede contener cualquier tipo de objeto. Esto permite que <code>ResponseDTO</code> sea reutilizable en distintos endpoints, adapt\u00e1ndose a las necesidades de cada uno.</p> </li> </ul>"},{"location":"chat-model/#paso-4controlador-chatcontroller","title":"Paso 4:Controlador <code>ChatController</code>","text":"<p>El controlador <code>ChatController</code> expone dos endpoints para interactuar con la IA de OpenAI. A trav\u00e9s de estos endpoints, los usuarios pueden enviar mensajes y obtener respuestas generadas por el modelo de IA. Este controlador permite:</p> <ul> <li>Generaci\u00f3n de texto simple en base a un mensaje.</li> <li>Generaci\u00f3n de conversaciones manteniendo un historial de mensajes, para que el modelo pueda tener contexto en las respuestas.</li> </ul> ChatController.java<pre><code>@RestController\n@RequestMapping(\"/chats\")\n@CrossOrigin(origins = \"*\")\n@RequiredArgsConstructor\npublic class ChatController {\n\n    private final OpenAiChatModel openAiChatModel;\n    private final ChatHistory chatHistory;\n\n    @GetMapping(\"/generate\")\n    public ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; generateText(@RequestParam String message) {\n        ChatResponse chatResponse = openAiChatModel.call(new Prompt(message));\n        String result = chatResponse.getResult().getOutput().getContent();\n\n        return ResponseEntity.ok(new ResponseDTO&lt;&gt;(200, \"success\", result));\n    }\n\n    @GetMapping(\"/generateConversation\")\n    public ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; generateConversation(@RequestParam String message){\n        chatHistory.addMessage(\"1\", new UserMessage(message));\n\n        ChatResponse chatResponse = openAiChatModel.call(new Prompt(chatHistory.getAll(\"1\")));\n        String result = chatResponse.getResult().getOutput().getContent();\n\n        return ResponseEntity.ok(new ResponseDTO&lt;&gt;(200, \"success\", result));\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1: <code>@RestController</code> Indica que esta clase es un controlador REST. Spring gestionar\u00e1 autom\u00e1ticamente las solicitudes HTTP y las respuestas en formato JSON.</p> </li> <li> <p>L\u00ednea 2: <code>@RequestMapping(\"/chats\")</code> Define el prefijo de la URL para todos los endpoints de este controlador (<code>/chats</code>).</p> </li> <li> <p>L\u00ednea 3: <code>@CrossOrigin(origins = \"*\")</code> Permite solicitudes CORS desde cualquier origen, lo cual es \u00fatil para desarrollo. En producci\u00f3n, puedes restringirlo a un dominio espec\u00edfico.</p> </li> <li> <p>L\u00ednea 4: <code>@RequiredArgsConstructor</code> Genera un constructor para inyectar los componentes <code>openAiChatModel</code> y <code>chatHistory</code> (gesti\u00f3n del historial de la conversaci\u00f3n), facilitando la inyecci\u00f3n de dependencias.</p> </li> </ul>"},{"location":"chat-model/#metodos-en-el-chatcontroller","title":"M\u00e9todos en el <code>ChatController</code>","text":"<ol> <li> <p>L\u00ednea 10: <code>generateText (@GetMapping(\"/generate\"))</code></p> <ul> <li>Objetivo: Generar una respuesta de texto simple en base a un mensaje proporcionado por el usuario.</li> <li>Par\u00e1metro: <code>message</code>, que contiene el texto enviado por el usuario.</li> <li>L\u00f3gica:<ul> <li>Crea una instancia de <code>Prompt</code> con el mensaje del usuario.</li> <li>Llama al m\u00e9todo <code>call</code> de <code>openAiChatModel</code>, que env\u00eda el <code>Prompt</code> a OpenAI.</li> <li>Obtiene la respuesta generada por el modelo (<code>chatResponse</code>) y extrae el contenido de texto (<code>result</code>).</li> </ul> </li> <li>Respuesta: Devuelve un <code>ResponseDTO</code> con el estado y el texto generado.</li> </ul> </li> <li> <p>L\u00ednea 18: <code>generateConversation (@GetMapping(\"/generateConversation\"))</code></p> <ul> <li>Objetivo: Generar una respuesta basada en una conversaci\u00f3n con contexto.</li> <li>Par\u00e1metro: message, que representa el mensaje actual del usuario.</li> <li>L\u00f3gica:<ul> <li>Agrega el mensaje al historial de conversaci\u00f3n (chatHistory) usando un identificador de conversaci\u00f3n (<code>\"1\"</code>).</li> <li>Env\u00eda todo el historial de mensajes al modelo, en lugar de solo el mensaje actual. Esto permite que el modelo de IA genere respuestas considerando el contexto.</li> <li>Obtiene y devuelve la respuesta generada, al igual que en el m\u00e9todo generateText.</li> </ul> </li> <li>Respuesta: Devuelve un <code>ResponseDTO</code> con el estado y la respuesta generada por el modelo de IA.</li> </ul> </li> </ol>"},{"location":"chat-model/#paso-5clase-chathistory","title":"Paso 5:Clase <code>ChatHistory</code>","text":"<p>La clase <code>ChatHistory</code> es un componente de Spring (<code>@Component</code>) que almacena el historial de mensajes para cada conversaci\u00f3n y permite realizar un seguimiento de los mensajes agregados. Esto permite que el modelo de IA tenga contexto en las respuestas, lo cual es \u00fatil para conversaciones continuas en las que cada mensaje depende de los anteriores.</p> ChatController.java<pre><code>@Component\npublic class ChatHistory {\n\n    private static final Logger logger = LoggerFactory.getLogger(ChatHistory.class);\n\n    private final Map&lt;String, List&lt;Message&gt;&gt; chatHistoryLog;\n    private final Map&lt;String, List&lt;Message&gt;&gt; messageAggregations;\n\n    public ChatHistory() {\n        this.chatHistoryLog = new ConcurrentHashMap&lt;&gt;();\n        this.messageAggregations = new ConcurrentHashMap&lt;&gt;();\n    }\n\n    public void addMessage(String chatId, Message message) {\n        String groupId = toGroupId(chatId, message);\n\n        this.messageAggregations.computeIfAbsent(groupId, key -&gt; new ArrayList&lt;&gt;()).add(message);\n\n        if (this.messageAggregations.size() &gt; 1) {\n            logger.warn(\"Multiple active sessions: {}\", this.messageAggregations.keySet());\n        }\n\n        String finishReason = getProperty(message, \"finishReason\");\n        if (\"STOP\".equalsIgnoreCase(finishReason) || message.getMessageType() == MessageType.USER) {\n            this.finalizeMessageGroup(chatId, groupId);\n        }\n    }\n\n    private String toGroupId(String chatId, Message message) {\n        String messageId = getProperty(message, \"id\");\n        return chatId + \":\" + messageId;\n    }\n\n    private String getProperty(Message message, String key) {\n        return message.getMetadata().getOrDefault(key, \"\").toString();\n    }\n\n    private void finalizeMessageGroup(String chatId, String groupId) {\n        List&lt;Message&gt; sessionMessages = this.messageAggregations.remove(groupId);\n\n        if (sessionMessages != null) {\n            if (sessionMessages.size() == 1) {\n                this.commitToHistoryLog(chatId, sessionMessages.get(0));\n            } else {\n                String aggregatedContent = sessionMessages.stream()\n                        .map(Message::getContent)\n                        .filter(Objects::nonNull)\n                        .collect(Collectors.joining());\n                this.commitToHistoryLog(chatId, new AssistantMessage(aggregatedContent));\n            }\n        } else {\n            logger.warn(\"No active session for groupId: {}\", groupId);\n        }\n    }\n\n    private void commitToHistoryLog(String chatId, Message message) {\n        this.chatHistoryLog.computeIfAbsent(chatId, key -&gt; new ArrayList&lt;&gt;()).add(message);\n    }\n\n    public List&lt;Message&gt; getAll(String chatId) {\n        return this.chatHistoryLog.getOrDefault(chatId, List.of());\n    }\n}\n</code></pre>"},{"location":"chat-model/#componentes-de-chathistory","title":"Componentes de <code>ChatHistory</code>","text":"<ul> <li> <p>L\u00ednea 1: <code>@Component</code> Indica que esta clase es un componente de Spring, lo que permite que Spring la gestione como un bean y la inyecte en otras clases.</p> </li> <li> <p>L\u00ednea 4: Logger: Se utiliza Logger para registrar advertencias, especialmente si se detectan m\u00faltiples sesiones activas o si no hay una sesi\u00f3n activa para un grupo de mensajes espec\u00edfico.</p> </li> <li> <p>Estructuras de Datos:</p> <ul> <li>L\u00ednea 6: <code>chatHistoryLog (Map&lt;String, List&lt;Message&gt;&gt;)</code> Este mapa almacena el historial completo de cada conversaci\u00f3n, agrupado por chatId. Cada chatId tiene una lista de mensajes que representa toda la conversaci\u00f3n.</li> <li>L\u00ednea 7: <code>messageAggregations (Map&lt;String, List&lt;Message&gt;&gt;)</code> Almacena mensajes agrupados temporalmente por sesi\u00f3n antes de que se finalicen y se registren en chatHistoryLog. Esta estructura permite manejar m\u00faltiples mensajes en una sesi\u00f3n, \u00fatil para conversaciones donde la IA responde en varias partes.</li> </ul> </li> </ul>"},{"location":"chat-model/#metodos-en-chathistory","title":"M\u00e9todos en ChatHistory","text":"<ul> <li> <p>L\u00ednea 14 addMessage(String chatId, Message message)</p> <ul> <li>Prop\u00f3sito: Agrega un mensaje a la sesi\u00f3n actual o crea una nueva si es necesario.</li> <li>Par\u00e1metros:<ul> <li>chatId: Identificador de la conversaci\u00f3n.</li> <li>message: El mensaje que se quiere agregar.</li> </ul> </li> <li>L\u00f3gica:<ul> <li>Genera un <code>groupId</code> \u00fanico para la sesi\u00f3n actual usando <code>chatId</code> y <code>message</code>.</li> <li>Agrega el mensaje a messageAggregations, y si hay varias sesiones activas, registra una advertencia.</li> <li>Verifica si el mensaje indica el fin de una conversaci\u00f3n (finishReason == \"STOP\") o si es un mensaje de usuario. Si es as\u00ed, llama a finalizeMessageGroup para guardar el mensaje en el historial permanente (chatHistoryLog).</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 29 toGroupId(String chatId, Message message):</p> <ul> <li>Prop\u00f3sito:Crea un identificador \u00fanico (groupId) para la sesi\u00f3n, combinando chatId y messageId.</li> <li>Uso: Asegura que cada sesi\u00f3n tenga un identificador \u00fanico basado en la conversaci\u00f3n y el mensaje.</li> </ul> </li> <li> <p>L\u00ednea 34 getProperty(Message message, String key):</p> <ul> <li>Prop\u00f3sito: Recupera el valor de una propiedad espec\u00edfica de message, como finishReason o id.</li> <li>Uso: Facilita el acceso a propiedades en el metadata del mensaje.</li> </ul> </li> <li> <p>L\u00ednea 38 finalizeMessageGroup(String chatId, String groupId):</p> <ul> <li>Prop\u00f3sito: Mueve los mensajes agrupados temporalmente desde messageAggregations al historial permanente en chatHistoryLog.</li> <li>L\u00f3gica:         - Elimina el grupo de mensajes de messageAggregations.         - Si solo hay un mensaje en el grupo, lo guarda directamente en el historial. Si hay varios, combina sus contenidos y luego lo guarda.         - Si no hay mensajes en el grupo, registra una advertencia de sesi\u00f3n inactiva.</li> </ul> </li> <li> <p>L\u00ednea 56 commitToHistoryLog(String chatId, Message message):</p> <ul> <li>Prop\u00f3sito: Agrega un mensaje al historial permanente chatHistoryLog.</li> <li>Uso: Llama a este m\u00e9todo cuando una sesi\u00f3n se ha finalizado, para registrar el contenido en el historial de conversaci\u00f3n.</li> </ul> </li> <li> <p>L\u00ednea 60 getAll(String chatId):</p> <ul> <li>Prop\u00f3sito: Devuelve el historial completo de mensajes para un chatId espec\u00edfico.</li> <li>Uso: Se utiliza en el controlador para recuperar el historial de una conversaci\u00f3n completa y enviarlo al modelo de IA para proporcionar contexto en las respuestas.</li> </ul> </li> </ul>"},{"location":"chat-model/#ejemplo-de-uso-en-el-segundo-endpoint","title":"Ejemplo de Uso en el Segundo Endpoint","text":"<p>En el endpoint <code>generateConversation</code> del <code>ChatController</code>, <code>ChatHistory</code> permite mantener un contexto de conversaci\u00f3n. Cada mensaje del usuario se agrega a <code>ChatHistory</code>, y luego se obtiene el historial completo de la conversaci\u00f3n antes de enviarlo al modelo de IA. Esto permite que la IA genere una respuesta considerando toda la conversaci\u00f3n hasta el momento.</p>"},{"location":"chat-model/#paso-6-prueba-del-endpoint-con-postman","title":"Paso 6: Prueba del Endpoint con Postman","text":"<p>Para asegurarnos de que el endpoint de conversaci\u00f3n funcione correctamente, utilizamos Postman para realizar una prueba. La Figura #1 muestra c\u00f3mo se realiz\u00f3 la prueba para el endpoint <code>/chats/generateConversation</code>.</p> <p></p> <p>Figura #1: Prueba del Endpoint <code>/chats/generateConversation</code> con Postman</p> <p>Descripci\u00f3n: En la Figura #1, se observa c\u00f3mo se configur\u00f3 y envi\u00f3 la solicitud en Postman:</p> <ol> <li> <p>M\u00e9todo y URL:</p> <ul> <li> <p>Se seleccion\u00f3 el m\u00e9todo GET y se ingres\u00f3 la URL:</p> <pre><code>http://localhost:8080/chats/generateConversation?message=Donde queda Guatemala?\n</code></pre> </li> <li> <p>Aqu\u00ed, el par\u00e1metro de consulta message se establece con el valor \"Donde queda Guatemala?\".</p> </li> </ul> </li> <li> <p>Par\u00e1metro de Consulta:</p> <ul> <li>En la secci\u00f3n Params de Postman, se agreg\u00f3 el par\u00e1metro de consulta <code>message</code> con el valor deseado, lo cual ser\u00e1 procesado por el modelo de IA para generar una respuesta contextualizada.</li> </ul> </li> <li> <p>Respuesta del Servidor:</p> <ul> <li> <p>En la parte inferior de la imagen, se muestra la respuesta recibida:</p> <pre><code>{\n    \"status\": 200,\n    \"message\": \"success\",\n    \"data\": \"Guatemala se encuentra en Am\u00e9rica Central. \n    Limita al norte y al oeste con M\u00e9xico, al este con Belice, \n    al sureste con Honduras y al sur con El Salvador. \n    Adem\u00e1s, tiene costas tanto en el Oc\u00e9ano Pac\u00edfico al suroeste \n    como en el Mar Caribe al este. \n    La ciudad capital de Guatemala es Ciudad de Guatemala.\"\n}\n</code></pre> </li> </ul> </li> <li> <p>Esta respuesta incluye:</p> <ul> <li><code>status</code>: Indica el estado de la solicitud, con <code>200</code> para confirmar que fue exitosa.</li> <li><code>message</code>: Un mensaje de \u00e9xito (<code>\"success\"</code>).</li> <li><code>data</code>: Contiene la respuesta generada por la IA, con informaci\u00f3n sobre Guatemala.</li> </ul> </li> </ol>"},{"location":"chat-model/#por-que-usamos-vaadin-en-el-proyecto","title":"\u00bfPor Qu\u00e9 Usamos Vaadin en el Proyecto?","text":"<p>Vaadin es un framework de Java que permite construir interfaces de usuario en el frontend directamente en Java, sin necesidad de escribir c\u00f3digo en HTML, CSS o JavaScript. Es especialmente \u00fatil para aplicaciones empresariales porque:</p> <ol> <li>Facilidad de Desarrollo: Vaadin permite a los desarrolladores trabajar en el frontend y el backend en Java, simplificando la integraci\u00f3n entre ambos.</li> <li>Componentes UI Listos para Usar: Ofrece una amplia gama de componentes de interfaz de usuario que pueden ser personalizados, lo que facilita la creaci\u00f3n de una UI rica y responsiva.</li> <li>Sin Necesidad de JavaScript: Permite crear aplicaciones web modernas sin tener que escribir JavaScript, ya que todo se maneja desde el backend en Java.</li> <li>Integraci\u00f3n Directa con Spring Boot: Vaadin se integra de manera fluida con Spring Boot, lo que hace que la construcci\u00f3n de aplicaciones Java completas sea m\u00e1s eficiente y menos compleja.</li> </ol> <p>En nuestro caso, Vaadin nos permite crear una interfaz interactiva para enviar mensajes al modelo de IA y mostrar respuestas, sin necesidad de manejar un frontend independiente.</p>"},{"location":"chat-model/#paso-7-clase-mainlayout","title":"Paso 7: Clase <code>MainLayout</code>","text":"<p>La clase <code>MainLayout</code> extiende <code>AppLayout</code>, una clase base en Vaadin que proporciona la estructura para layouts de aplicaciones con una barra de navegaci\u00f3n superior y un men\u00fa lateral. Este layout permite que todas las vistas de nuestra aplicaci\u00f3n compartan la misma estructura.</p> MainLayout.java<pre><code>@Layout\npublic class MainLayout extends AppLayout {\n\n    public MainLayout() {\n        var head = new HorizontalLayout();\n        head.setDefaultVerticalComponentAlignment(FlexComponent.Alignment.CENTER);\n        head.add(new DrawerToggle());\n        head.add(new H2(\"Spring AI\"){{addClassNames(LumoUtility.FontSize.LARGE);}});\n\n        addToNavbar(head);\n\n        var sideBar = new VerticalLayout();\n\n        MenuConfiguration.getMenuEntries().forEach(menuEntry -&gt; {\n            sideBar.add(new RouterLink(menuEntry.title(), menuEntry.menuClass()));\n        });\n\n        addToDrawer(sideBar);\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1 <code>@Layout</code>: Aunque no es una anotaci\u00f3n est\u00e1ndar en Java, en este contexto parece una convenci\u00f3n o anotaci\u00f3n personalizada (probablemente configurada en el proyecto) que designa esta clase como el layout principal para otras vistas en Vaadin.</p> </li> <li> <p>L\u00ednea 1 Extiende <code>AppLayout</code>: <code>AppLayout</code> es la clase base de Vaadin para layouts de aplicaciones con un men\u00fa lateral y una barra de navegaci\u00f3n superior. Al extender <code>AppLayout</code>, <code>MainLayout</code> se convierte en el layout principal de la aplicaci\u00f3n, proporcionando un dise\u00f1o com\u00fan para todas las vistas.</p> </li> <li> <p>L\u00ednea 4 - Constructor <code>MainLayout()</code>:</p> <ul> <li>Barra de Navegaci\u00f3n Superior (Navbar):<ul> <li>Se crea un <code>HorizontalLayout</code> llamado <code>head</code>que contiene los elementos de la barra de navegaci\u00f3n superior.</li> <li><code>DrawerToggle</code>: Este componente agrega un icono de \"men\u00fa hamburguesa\" (tres l\u00edneas horizontales) en la barra de navegaci\u00f3n superior. Al hacer clic en este icono, el men\u00fa lateral se abre o se cierra. Esto es especialmente \u00fatil en dispositivos m\u00f3viles o pantallas peque\u00f1as, ya que permite al usuario ocultar o mostrar el men\u00fa lateral para aprovechar mejor el espacio en pantalla.</li> <li><code>T\u00edtulo</code>: A\u00f1adimos un t\u00edtulo con el texto \"Spring AI\" usando un componente <code>H2</code>. Aplicamos estilos para que el tama\u00f1o de la fuente sea grande (<code>LumoUtility.FontSize.LARGE</code>).</li> <li><code>addToNavbar(head)</code>: Este m\u00e9todo a\u00f1ade el <code>head</code> a la barra de navegaci\u00f3n superior.</li> </ul> </li> <li>Men\u00fa Lateral (Sidebar):<ul> <li>Se crea un <code>VerticalLayout</code> llamado <code>sideBar</code>para el men\u00fa lateral.</li> <li><code>Men\u00fa Din\u00e1mico</code>: Utilizamos <code>MenuConfiguration.getMenuEntries()</code> para obtener las entradas de men\u00fa configuradas en el proyecto. Para cada entrada, se crea un enlace de navegaci\u00f3n (<code>RouterLink</code>) que redirige a la clase correspondiente.</li> <li><code>addToDrawer(sideBar)</code>: Este m\u00e9todo a\u00f1ade el <code>sideBar</code> al drawer o men\u00fa lateral.</li> </ul> </li> <li>Prop\u00f3sito del <code>MainLayout</code>:<ul> <li>El MainLayout tiene dos objetivos principales:<ul> <li><code>Uniformidad</code>: Al utilizar un layout com\u00fan para todas las vistas, la aplicaci\u00f3n mantiene un dise\u00f1o consistente en cada secci\u00f3n. Esto asegura que el usuario tenga una experiencia visual uniforme, independientemente de la vista que est\u00e9 utilizando, lo cual mejora la experiencia y facilita la navegaci\u00f3n.</li> <li><code>Modularidad</code>: Separar el layout principal del contenido espec\u00edfico de cada vista permite agregar, modificar o eliminar vistas sin afectar la estructura general de la interfaz. Esto significa que podemos cambiar el contenido de las vistas individuales sin necesidad de ajustar el dise\u00f1o principal.</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>Ahora vamos a agregar la clase <code>HomeView</code>, que servir\u00e1 como la vista principal de la aplicaci\u00f3n. Esta vista se mostrar\u00e1 en la ruta ra\u00edz (<code>/</code>) de la aplicaci\u00f3n y utilizar\u00e1 <code>MainLayout</code> como layout base.</p> HomeView.java<pre><code>@Route(value = \"\", layout = MainLayout.class)  // Ruta principal\npublic class HomeView extends VerticalLayout {\n    public HomeView() {\n        add(new H1(\"Welcome to Enterprise AI Jug Guatemala 2024\"));\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1 - <code>@Route</code>:</p> <ul> <li><code>value = \"\":</code> Define la ruta de esta vista como la ra\u00edz de la aplicaci\u00f3n (<code>/</code>). Esto significa que cuando los usuarios accedan a <code>http://localhost:8080</code>, se les mostrar\u00e1 esta vista.</li> <li><code>layout = MainLayout.class</code>: Especifica que <code>HomeView</code> usar\u00e1 <code>MainLayout</code> como su layout base. Esto asegura que la vista de inicio tenga la misma estructura de navegaci\u00f3n y dise\u00f1o que el resto de las vistas de la aplicaci\u00f3n.</li> </ul> </li> <li> <p>L\u00ednea 1 - <code>VerticalLayout</code>:</p> <ul> <li><code>HomeView</code> extiende <code>VerticalLayout</code>, que es un layout vertical en Vaadin. Esto organiza los componentes que contiene de manera vertical.</li> <li>Al extender <code>VerticalLayout</code>, <code>HomeView</code> puede a\u00f1adir componentes uno debajo del otro, aprovechando la alineaci\u00f3n vertical.</li> </ul> </li> <li> <p>L\u00edneas 3-4: Constructor de <code>HomeView</code>:</p> <ul> <li><code>add(new H1(\"Welcome to Enterprise AI Jug Guatemala 2024\"))</code>: A\u00f1ade un t\u00edtulo principal (<code>H1</code>) con el mensaje \"Welcome to Enterprise AI Jug Guatemala 2024\". Este mensaje se mostrar\u00e1 en la pantalla principal de la aplicaci\u00f3n y sirve como bienvenida para los usuarios.</li> </ul> </li> </ul> <p><code>HomeView</code> act\u00faa como la p\u00e1gina de bienvenida de la aplicaci\u00f3n. Al utilizar <code>MainLayout</code>, garantiza que la estructura de la barra de navegaci\u00f3n superior y el men\u00fa lateral est\u00e9n presentes, proporcionando una experiencia de usuario consistente desde el primer acceso. Esta vista es perfecta para dar una introducci\u00f3n o mensaje de bienvenida a los usuarios.</p>"},{"location":"chat-model/#paso-8-adicionar-el-formulario-basiccallview","title":"Paso 8: Adicionar el Formulario <code>BasicCallView</code>","text":"<p>El formulario en BasicCallView como se muestra en la figura #2 permite al usuario enviar mensajes al backend y recibir respuestas generadas por un modelo de IA. La interfaz est\u00e1 dise\u00f1ada para simular un chat b\u00e1sico donde el usuario puede ingresar una pregunta o mensaje, enviarlo, y ver la respuesta del \"bot\" en tiempo real.</p> <p> Figura #2: interfaz en acci\u00f3n</p>"},{"location":"chat-model/#componentes-del-formulario","title":"Componentes del Formulario","text":"<ol> <li> <p>Campo de Entrada de Mensaje (TextArea): El usuario ingresa el mensaje en el \u00e1rea de texto etiquetada como \"Enter your message:\". Esta \u00e1rea de texto es amplia y est\u00e1 dise\u00f1ada para mensajes largos.</p> </li> <li> <p>Botones de Acci\u00f3n:</p> <ul> <li>Send: Env\u00eda el mensaje al backend cuando se hace clic. La respuesta generada por la IA se muestra en el \u00e1rea de mensajes justo debajo.</li> <li>Clear: Limpia tanto el \u00e1rea de entrada de texto como el historial de mensajes.</li> </ul> </li> <li> <p>\u00c1rea de Mensajes: Las respuestas generadas por el modelo de IA se presentan en esta secci\u00f3n. Cada respuesta aparece en un contenedor separado, con estilo, para diferenciarlo del \u00e1rea de entrada. BasicCallView.java<pre><code>@Route(\"chat\")\n@Menu(title = \"Basic Calling\", order = 1)\npublic class BasicCallView extends VerticalLayout {\n\n    private final RestTemplate restTemplate = new RestTemplate();  // Cliente para hacer solicitudes HTTP\n    private final String backendUrl = \"http://localhost:8080/chats/generateConversation\";  // URL de tu controlador\n\n    public BasicCallView() {\n        setSizeFull();\n\n        TextArea messageInput = new TextArea(\"Enter your message:\");\n        messageInput.setWidth(\"600px\"); // Ajusta el ancho del \u00e1rea de texto\n        messageInput.setHeight(\"150px\"); // Ajusta la altura del \u00e1rea de texto\n\n        Button sendButton = new Button(\"Send\");\n        Button clearButton = new Button(\"Clear\");\n\n        // Area para mostrar la respuesta\n        VerticalLayout messages = new VerticalLayout();\n        messages.setWidth(\"600px\");\n\n        // Layout horizontal para los botones\n        HorizontalLayout buttonLayout = new HorizontalLayout(sendButton, clearButton);\n\n        sendButton.addClickListener(click -&gt; {\n            String message = messageInput.getValue();\n            // Usando ParameterizedTypeReference para manejar el tipo de datos gen\u00e9rico\n            ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; responseEntity = restTemplate.exchange(\n                    backendUrl + \"?message=\" + message,\n                    HttpMethod.GET,\n                    null,\n                    new ParameterizedTypeReference&lt;ResponseDTO&lt;String&gt;&gt;() {}\n            );\n\n\n            if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {\n                String response = responseEntity.getBody().getData();  // Extraer el mensaje de respuesta\n               // messages.add(new Paragraph(\"Bot: \" + response));\n                Div responseContainer = new Div();\n                responseContainer.getStyle()\n                        .set(\"padding\", \"10px\")\n                        .set(\"margin-top\", \"10px\")\n                        .set(\"background-color\", \"#f1f3f4\")\n                        .set(\"border-radius\", \"8px\")\n                        .set(\"border\", \"1px solid #e0e0e0\");\n                responseContainer.add(new Paragraph(\"Bot: \" + response));\n                messages.add(responseContainer);\n            } else {\n                messages.add(new Paragraph(\"Error: Failed to get response from backend\"));\n            }\n        });\n\n        // Bot\u00f3n para limpiar el \u00e1rea de mensajes\n        clearButton.addClickListener(click -&gt; {\n            messages.removeAll();\n            messageInput.clear();\n        });\n\n        add(messageInput, buttonLayout, messages);\n    }\n}\n</code></pre></p> </li> <li> <p>L\u00ednea 1 <code>@Route(\"chat\")</code>: Define la ruta de esta vista como <code>/chat</code>. Esto significa que cuando accedemos a <code>http://localhost:8080/chat</code>, se mostrar\u00e1 esta vista.</p> </li> <li> <p>L\u00ednea 2 <code>@Menu(title = \"Basic Calling\", order = 1)</code>: Anotaci\u00f3n personalizada (probablemente configurada en el proyecto) para definir el t\u00edtulo y el orden del elemento en el men\u00fa de navegaci\u00f3n. El t\u00edtulo es \"Basic Calling\" y la posici\u00f3n en el men\u00fa es la primera (<code>order = 1</code>).</p> </li> <li> <p>L\u00ednea 3 <code>public class BasicCallView extends VerticalLayout</code>: Define la clase <code>BasicCallView</code> que extiende <code>VerticalLayout</code>. Esto significa que los componentes a\u00f1adidos se organizar\u00e1n verticalmente.</p> </li> <li> <p>L\u00ednea 5 <code>String backendUrl = \"http://localhost:8080/chats/generateConversation\";</code>: Define la URL del endpoint del backend al que se enviar\u00e1n las solicitudes para obtener respuestas de la IA.</p> </li> <li> <p>L\u00ednea 6 <code>setSizeFull();</code>: Configura el tama\u00f1o de BasicCallView para que ocupe todo el espacio disponible en la pantalla.</p> </li> <li> <p>L\u00ednea 9 <code>RestTemplate restTemplate = new RestTemplate();</code>: Crea una instancia de RestTemplate, un cliente HTTP de Spring para realizar solicitudes HTTP al backend.</p> </li> </ol>"},{"location":"chat-model/#configuracion-de-los-componentes-de-la-interfaz","title":"Configuraci\u00f3n de los Componentes de la Interfaz","text":"<ul> <li> <p>L\u00ednea 11 <code>TextArea messageInput = new TextArea(\"Enter your message:\");</code>: Crea un \u00e1rea de texto (<code>TextArea</code>) para que el usuario ingrese su mensaje. El texto \"Enter your message:\" se muestra como etiqueta.</p> </li> <li> <p>L\u00ednea 12 <code>messageInput.setWidth(\"600px\");</code>: Define el ancho del \u00e1rea de texto como <code>600px</code>.</p> </li> <li> <p>L\u00ednea 13 <code>messageInput.setHeight(\"150px\");</code>: Define la altura del \u00e1rea de texto como <code>150px</code>.</p> </li> <li> <p>L\u00ednea 15 <code>Button sendButton = new Button(\"Send\");</code>: Crea un bot\u00f3n llamado \"Send\" para enviar el mensaje al backend.</p> </li> <li> <p>L\u00ednea 16 <code>Button clearButton = new Button(\"Clear\");</code>: Crea un bot\u00f3n llamado \"Clear\" para limpiar el \u00e1rea de mensajes y el campo de entrada.</p> </li> </ul>"},{"location":"chat-model/#configuracion-del-area-de-mensajes","title":"Configuraci\u00f3n del \u00c1rea de Mensajes","text":"<ul> <li> <p>L\u00ednea 19 <code>VerticalLayout messages = new VerticalLayout();</code>: Crea un <code>VerticalLayout</code> para organizar las respuestas generadas por la IA de manera vertical, una debajo de la otra.</p> </li> <li> <p>L\u00ednea 20 <code>messages.setWidth(\"600px\");</code>: Define el ancho del \u00e1rea de mensajes como <code>600px</code>, igual que el \u00e1rea de entrada de texto, para mantener consistencia en el dise\u00f1o.</p> </li> </ul>"},{"location":"chat-model/#configuracion-del-layout-de-los-botones","title":"Configuraci\u00f3n del Layout de los Botones","text":"<ul> <li>L\u00ednea 23 <code>HorizontalLayout buttonLayout = new HorizontalLayout(sendButton, clearButton);</code>: Crea un HorizontalLayout que contiene los botones sendButton y clearButton, organiz\u00e1ndolos horizontalmente en la interfaz.</li> </ul>"},{"location":"chat-model/#boton-send","title":"Bot\u00f3n \"Send\"","text":"<ul> <li> <p>L\u00ednea 25 <code>sendButton.addClickListener(click -&gt; { ... })</code>: A\u00f1ade un listener al bot\u00f3n \"Send\" para definir lo que ocurre al hacer clic. Aqu\u00ed se maneja el evento de enviar el mensaje al backend.</p> </li> <li> <p>L\u00ednea 26 <code>String message = messageInput.getValue();</code>: Obtiene el valor ingresado por el usuario en el messageInput y lo guarda en la variable message.</p> </li> <li> <p>L\u00edneas 28-33 <code>ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; responseEntity = restTemplate.exchange(...)</code>: Realiza una solicitud HTTP GET al backend.</p> <ul> <li><code>backendUrl + \"?message=\" + message</code>: Construye la URL con el mensaje como par\u00e1metro de consulta.</li> <li><code>HttpMethod.GET</code>: Define el m\u00e9todo de la solicitud como GET.</li> <li><code>null</code>: No se pasan encabezados o cuerpo en la solicitud.</li> <li><code>new ParameterizedTypeReference&lt;ResponseDTO&lt;String&gt;&gt;() {}</code>: Define el tipo de respuesta esperada como <code>ResponseDTO&lt;String&gt;</code>, permitiendo a <code>RestTemplate</code> manejar respuestas gen\u00e9ricas.</li> </ul> </li> <li> <p>L\u00ednea 36 <code>if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null)</code>: Verifica si la solicitud fue exitosa (c\u00f3digo 2xx) y si el cuerpo de la respuesta no es nulo.</p> </li> <li>L\u00ednea 37 <code>String response = responseEntity.getBody().getData();</code>: Obtiene el campo <code>data</code> de la respuesta, que contiene el mensaje generado por la IA.</li> <li>L\u00ednea 39 <code>Div responseContainer = new Div();</code>: Crea un contenedor (<code>Div</code>) para mostrar el mensaje de respuesta de la IA.</li> <li> <p>L\u00edneas 40-45 <code>responseContainer.getStyle().set(...)</code>: Aplica estilos CSS para mejorar la apariencia del contenedor:</p> <ul> <li><code>padding</code>: Espacio interno de <code>10px</code>.</li> <li><code>margin-top</code>: Espacio superior de <code>10px</code> entre mensajes.</li> <li><code>background-color</code>: Fondo gris claro.</li> <li><code>border-radius</code>: Bordes redondeados de <code>8px</code>.</li> <li><code>border</code>: Borde gris claro.</li> </ul> </li> <li> <p>L\u00ednea 46 <code>responseContainer.add(new Paragraph(\"Bot: \" + response));</code>: A\u00f1ade el mensaje de respuesta de la IA dentro del responseContainer, precedido por el texto \"Bot:\".</p> </li> <li>L\u00ednea 47 <code>messages.add(responseContainer);</code>: Agrega el <code>responseContainer</code> (con la respuesta) al \u00e1rea de mensajes (<code>messages</code>), para mostrarlo en la interfaz.</li> <li>L\u00edneas 48-50 <code>else { messages.add(new Paragraph(\"Error: Failed to get response from backend\")); }</code>: Si la solicitud falla, muestra un mensaje de error en el \u00e1rea de mensajes.</li> </ul>"},{"location":"chat-model/#boton-clear","title":"Bot\u00f3n \"Clear\"","text":"<ul> <li>L\u00ednea 54 <code>clearButton.addClickListener(click -&gt; { ... })</code>: A\u00f1ade un listener al bot\u00f3n \"Clear\" para definir lo que ocurre al hacer clic.</li> <li>L\u00ednea 55 <code>messages.removeAll();</code>: Limpia el \u00e1rea de mensajes, eliminando todos los mensajes mostrados previamente.</li> <li>L\u00ednea 56 <code>messageInput.clear();</code>: Limpia el \u00e1rea de texto de entrada, eliminando el mensaje ingresado por el usuario.</li> <li>L\u00ednea 59 <code>add(messageInput, buttonLayout, messages);</code>: A\u00f1ade el \u00e1rea de texto de entrada (<code>messageInput</code>), el layout de botones (<code>buttonLayout</code>) y el \u00e1rea de mensajes (<code>messages</code>) al <code>BasicCallView</code>, organiz\u00e1ndolos verticalmente.</li> </ul>"},{"location":"configuracion-entorno/","title":"Configuraci\u00f3n de Entorno","text":""},{"location":"configuracion-entorno/#paso-1-configuracion-del-proyecto-en-spring-initializr","title":"Paso 1: Configuraci\u00f3n del Proyecto en Spring Initializr","text":"<p>Para comenzar, accede a Spring initialzr y configura el proyecto de la siguiente manera:</p> <ul> <li>Project: Maven</li> <li>Language: Java</li> <li>Spring Boot: 3.+ (la \u00faltima versi\u00f3n estable)</li> <li>Project Metadata:<ul> <li>Group: com.geovannycode</li> <li>Artifact: springai</li> <li>Name: springai</li> </ul> </li> <li>Packaging: Jar</li> <li>Java: 21</li> </ul>"},{"location":"configuracion-entorno/#paso-2-adicionar-dependencias","title":"Paso 2: Adicionar Dependencias","text":"<p>Agregamos las siguientes dependencias en el archivo <code>pom.xml</code>:</p> <p></p> <p>Agrega las siguientes dependencias en el archivo pom.xml para preparar tu proyecto. Cada dependencia tiene un prop\u00f3sito espec\u00edfico que te ayudar\u00e1 a lograr la funcionalidad deseada en el workshop.</p> <ol> <li> <p>OpenAI - <code>spring-ai-openai-spring-boot-starter</code> Esta dependencia permite la integraci\u00f3n de Spring AI con modelos de inteligencia artificial de OpenAI, incluyendo modelos como ChatGPT y DALL-E para generaci\u00f3n de texto e im\u00e1genes. Con esta dependencia, podr\u00e1s acceder a funcionalidades avanzadas de IA para agregar capacidades de generaci\u00f3n de contenido a tu aplicaci\u00f3n.</p> </li> <li> <p>Spring Web - <code>spring-boot-starter-web</code> Proporciona las herramientas necesarias para construir aplicaciones web, incluyendo API REST. Utiliza Spring MVC y Apache Tomcat como servidor web embebido, lo que facilita la creaci\u00f3n de endpoints HTTP para que los usuarios puedan interactuar con tu aplicaci\u00f3n a trav\u00e9s de la web.</p> </li> <li> <p>Spring Data JPA - <code>spring-boot-starter-data-jpa</code> Esta dependencia te permite trabajar con bases de datos SQL de forma m\u00e1s eficiente mediante la API de Persistencia de Java (JPA). Proporciona herramientas para realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en tu base de datos, simplificando el acceso a datos y la persistencia.</p> </li> <li> <p>Docker Compose Support - <code>spring-boot-docker-compose</code> Esta dependencia facilita la configuraci\u00f3n y gesti\u00f3n de contenedores Docker en tu proyecto. Al usar Docker Compose, puedes ejecutar m\u00faltiples servicios, como bases de datos, en contenedores, lo que facilita el despliegue de ambientes de desarrollo completos.</p> </li> <li> <p>Vaadin - <code>vaadin-spring-boot-starter</code> Vaadin es un framework para construir aplicaciones web modernas y reactivas con Java. Con esta dependencia, podr\u00e1s crear interfaces de usuario de manera sencilla utilizando componentes visuales y vistas completamente en Java o integrando tecnolog\u00edas como Hilla para un enfoque m\u00e1s din\u00e1mico.</p> </li> <li> <p>Lombok - <code>lombok</code> Lombok es una biblioteca que reduce el c\u00f3digo repetitivo en Java, como getters, setters, y constructores. Es muy \u00fatil para simplificar el c\u00f3digo y mantenerlo limpio y legible, especialmente en clases que necesitan muchas propiedades y m\u00e9todos de acceso.</p> </li> <li> <p>PostgreSQL Driver - <code>postgresql</code> Proporciona el controlador JDBC para conectarse a una base de datos PostgreSQL, permitiendo la comunicaci\u00f3n entre tu aplicaci\u00f3n y la base de datos. Esta dependencia es esencial para almacenar y recuperar datos desde PostgreSQL.</p> </li> <li> <p>Spring Boot Starter Test - <code>spring-boot-starter-test</code> Incluye herramientas para pruebas unitarias e integradas en Spring Boot, como JUnit y Mockito. Esta dependencia es \u00fatil para asegurarte de que tu c\u00f3digo funciona correctamente antes de desplegarlo.</p> </li> </ol>"},{"location":"configuracion-entorno/#paso-3-generacion-y-configuracion-del-proyecto","title":"Paso 3: Generaci\u00f3n y Configuraci\u00f3n del Proyecto","text":"<p>Una vez configuradas todas las opciones y dependencias, presiona el bot\u00f3n \"Generate\" en Spring Initializr para generar el proyecto. Descarga el archivo .zip, descompr\u00edmelo y abre el proyecto en tu IDE preferido, como IntelliJ IDEA.</p> <p>Con estas dependencias configuradas, estar\u00e1s listo para comenzar a desarrollar la aplicaci\u00f3n. A continuaci\u00f3n, detallar\u00e9 los pasos para configurar el entorno y explicar\u00e9 c\u00f3mo utilizar cada dependencia en el contexto del proyecto.</p>"},{"location":"configuracion-entorno/#paso-4-crear-los-paquetes","title":"Paso 4: Crear los Paquetes","text":"<p>Basado en tu estructura, necesitamos los siguientes paquetes:</p> <ol> <li>model: Contendr\u00e1 las clases de entidad o modelo.</li> <li>dto: Aqu\u00ed almacenaremos los objetos de transferencia de datos (DTOs) que utilizaremos para la comunicaci\u00f3n entre el frontend y el backend.</li> <li>repo: Este paquete contendr\u00e1 las interfaces que representan los repositorios (interfaces de JPA) para interactuar con la base de datos.</li> <li>service: Contendr\u00e1 la l\u00f3gica de negocio, dividiendo entre interfaces y sus implementaciones en el subpaquete <code>impl</code>.</li> <li>controller: Este paquete contendr\u00e1 los controladores para gestionar las solicitudes HTTP.</li> </ol>"},{"location":"configuracion-entorno/#paso-5-paquete-model","title":"Paso 5: Paquete model","text":"<p>En una aplicaci\u00f3n que sigue la arquitectura MVC (Modelo-Vista-Controlador), el paquete <code>model</code> se encarga de representar el \"Modelo\" de datos de la aplicaci\u00f3n. Aqu\u00ed es donde definimos las clases que mapean las entidades de negocio que queremos almacenar y gestionar en nuestra base de datos.</p> <p>En este caso, el paquete <code>com.geovannycode.model</code> contendr\u00e1 las clases <code>Author</code> y <code>Book</code>, que representan respectivamente a los autores y libros en el contexto de nuestra aplicaci\u00f3n. Estas clases de modelo (o entidades) ser\u00e1n mapeadas a tablas en la base de datos mediante las anotaciones de JPA (Java Persistence API), lo que nos permite trabajar con datos persistentes de una manera orientada a objetos.</p> <p>En nuestro caso, el paquete <code>model</code> contendr\u00e1 las clases <code>Author</code> y <code>Book</code>, que definir\u00e1n los atributos y relaciones de las entidades \"Autor\" y \"Libro\", permiti\u00e9ndonos interactuar con estos datos de manera estructurada y consistente.</p> Author.java<pre><code>import jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Data\npublic class Author {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private int idAuthor;\n\n    @Column(nullable = false, length = 50)\n    private String firstName;\n\n    @Column(nullable = false, length = 50)\n    private String lastName;\n\n    @Column(nullable = false, length = 35)\n    private String country;\n\n    @Column(nullable = false, length = 500)\n    private String urlPhoto;\n}\n</code></pre> <ul> <li>L\u00edneas 11-12: <code>@AllArgsConstructor</code> y <code>@NoArgsConstructor</code> Lombok genera un constructor con todos los argumentos y un constructor sin argumentos.</li> <li>L\u00edneas 13: <code>@Entity</code> Indica que esta clase es una entidad de <code>JPA</code>, lo que significa que estar\u00e1 mapeada a una tabla en la base de datos.</li> <li>L\u00edneas 14: <code>@Data</code>: Genera autom\u00e1ticamente getters, setters, y otros m\u00e9todos como <code>toString()</code>, <code>equals()</code>, y <code>hashCode()</code>, gracias a Lombok.</li> <li>L\u00edneas 17-19: <code>@Id</code> y <code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>: Configura idAuthor como la clave primaria y define que se generar\u00e1 autom\u00e1ticamente.</li> <li>L\u00edneas 21: <code>@Column</code> Define restricciones para los campos de la entidad, como nullable, y establece l\u00edmites de longitud para los atributos firstName, lastName, country, y urlPhoto.</li> </ul> Book.java<pre><code>import jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\npublic class Book {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private int idBook;\n\n    @Column(nullable = false, length = 50)\n    private String name;\n\n    @Column(nullable = false, length = 2000)\n    private String review;\n\n    @ManyToOne\n    @JoinColumn(name = \"id_author\", nullable = false)\n    private Author author;\n\n    @Column(nullable = false, length = 500)\n    private String urlCover;\n\n    @Column(nullable = false)\n    private boolean enabled;\n}\n</code></pre> <ul> <li>L\u00edneas 11-12: <code>@Data</code>, <code>@AllArgsConstructor</code>, <code>@NoArgsConstructor</code>, <code>@Entity</code> Las mismas anotaciones y sus funciones, como en la clase Author.</li> <li>L\u00edneas 21: <code>@Column</code> Define las restricciones de los campos, incluyendo <code>name</code>, <code>review</code>, y <code>urlCover</code>.</li> <li>L\u00edneas 27: <code>@ManyToOne</code> y <code>@JoinColumn(name = \"id_author\", nullable = false)</code> Define una relaci\u00f3n de muchos a uno con la clase <code>Author</code>, especificando que cada libro pertenece a un autor. <code>id_author</code> es la columna de clave externa en la base de datos que relaciona ambas entidades.</li> <li>L\u00edneas 35: <code>boolean enabled</code> Este campo que representa si el libro est\u00e1 activo o no, con una restricci\u00f3n nullable = false para garantizar que siempre tenga un valor.</li> </ul>"},{"location":"configuracion-entorno/#paso-6-paquete-repo","title":"Paso 6: Paquete repo","text":"<p>En la arquitectura de una aplicaci\u00f3n basada en MVC, el paquete <code>repo</code>(abreviatura de \"repository\") es donde definimos las interfaces que se encargan de la interacci\u00f3n directa con la base de datos. Estas interfaces representan los \"Repositorios\" que permiten realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) y consultas espec\u00edficas en nuestras entidades de negocio (en este caso, <code>Author</code> y <code>Book</code>).</p> <p>En este paquete, ubicaremos las interfaces <code>IAuthorRepo</code> e <code>IBookRepo</code>, las cuales extienden de <code>JpaRepository</code>. Esta extensi\u00f3n nos facilita la gesti\u00f3n de nuestras entidades mediante JPA, ya que hereda un conjunto de m\u00e9todos predefinidos para realizar operaciones comunes sin tener que escribir c\u00f3digo adicional.</p>"},{"location":"configuracion-entorno/#creacion-de-las-interfaces-iauthorrepo-e-ibookrepo","title":"Creaci\u00f3n de las Interfaces IAuthorRepo e IBookRepo","text":"IAuthorRepo.java<pre><code>import com.geovannycode.model.Author;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface IAuthorRepo extends JpaRepository&lt;Author, Integer&gt; {}\n</code></pre> <ul> <li><code>IAuthorRepo</code>: Es una interfaz que extiende de JpaRepository, la cual est\u00e1 dise\u00f1ada para la entidad <code>Author</code>.</li> <li><code>JpaRepository&lt;Author, Integer&gt;</code>: Al extender de <code>JpaRepository</code>, estamos indicando que esta interfaz manejar\u00e1 la entidad <code>Author</code> con una clave primaria de tipo <code>Integer</code>. Esto nos proporciona m\u00e9todos predeterminados para realizar operaciones CRUD en la tabla <code>Author</code>, como <code>findAll()</code>, <code>findById()</code>, <code>save()</code>, y <code>deleteById()</code>.</li> </ul> <p>Ventaja: Spring Data JPA proporciona autom\u00e1ticamente la implementaci\u00f3n de estos m\u00e9todos, por lo que no necesitamos escribir c\u00f3digo adicional para operaciones b\u00e1sicas en la entidad Author.</p> IBookRepo.java<pre><code>import com.geovannycode.model.Book;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.List;\n\npublic interface IBookRepo extends JpaRepository&lt;Book, Integer&gt; {\n    List&lt;Book&gt; findByNameLike(String name);\n}\n</code></pre> <ul> <li>L\u00edneas 7: <code>findByNameLike(String name)</code> Aqu\u00ed hemos definido un m\u00e9todo adicional para realizar una b\u00fasqueda personalizada. Este m\u00e9todo busca libros cuyo nombre sea similar al par\u00e1metro <code>name</code> (utilizando el operador SQL <code>LIKE</code> internamente). La convenci\u00f3n de nombre <code>findByNameLike</code>permite que Spring Data JPA implemente autom\u00e1ticamente el m\u00e9todo sin que sea necesario escribir una consulta SQL expl\u00edcita.</li> </ul> <p>Ventaja: La capacidad de definir m\u00e9todos personalizados con convenios de nomenclatura en las interfaces de repositorio hace que las consultas personalizadas sean f\u00e1ciles de implementar y entender.</p>"},{"location":"configuracion-entorno/#paso-7-paquete-service","title":"Paso 7: Paquete service","text":"<p>La capa de servicio en la arquitectura de una aplicaci\u00f3n MVC contiene la l\u00f3gica de negocio. En esta capa, creamos interfaces y sus implementaciones que definen las operaciones que la aplicaci\u00f3n realizar\u00e1 sobre las entidades de datos (<code>Author</code> y <code>Book</code>). Esta capa act\u00faa como un intermediario entre los controladores (que reciben las solicitudes del usuario) y los repositorios (que interact\u00faan con la base de datos).</p> <p>En este caso, vamos a crear un enfoque gen\u00e9rico utilizando una interfaz llamada <code>ICRUD</code> que definir\u00e1 los m\u00e9todos CRUD (Crear, Leer, Actualizar, Eliminar) de forma gen\u00e9rica. Las interfaces espec\u00edficas <code>IBookService</code> e <code>IAuthorService</code> extender\u00e1n de <code>ICRUD</code>, heredando as\u00ed los m\u00e9todos CRUD b\u00e1sicos.</p> <p>Interfaz Gen\u00e9rica <code>ICRUD</code> La interfaz ICRUD permite definir m\u00e9todos gen\u00e9ricos para operaciones CRUD. Esto nos permite reutilizar esta interfaz para diferentes tipos de datos, en lugar de escribir m\u00e9todos repetitivos en cada servicio espec\u00edfico.</p> ICRUD.java<pre><code>import java.util.List;\n\npublic interface ICRUD&lt;T, ID&gt; {\n\n    T save(T t) throws Exception;\n    List&lt;T&gt; saveAll(List&lt;T&gt; t) throws Exception;\n    T update(T t, ID id) throws Exception;\n    List&lt;T&gt; findAll() throws Exception;\n    T findById(ID id) throws Exception;\n    void delete(ID id) throws Exception;\n}\n</code></pre> <p><code>T</code> y <code>ID</code>: Son par\u00e1metros gen\u00e9ricos. <code>T</code> representa el tipo de entidad (como <code>Author</code> o <code>Book</code>), e <code>ID</code> representa el tipo de clave primaria (como <code>Integer</code>).</p> <ul> <li>M\u00e9todos CRUD:<ul> <li><code>save(T t)</code>: Guarda una entidad en la base de datos.</li> <li><code>saveAll(List&lt;T&gt; t)</code>: Guarda una lista de entidades en la base de datos.</li> <li><code>update(T t, ID id)</code>: Actualiza una entidad existente con un ID espec\u00edfico.</li> <li><code>findAll()</code>: Devuelve todas las entidades.</li> <li><code>findById(ID id)</code>: Devuelve una entidad seg\u00fan el ID.</li> <li><code>delete(ID id)</code>: Elimina una entidad seg\u00fan el ID.</li> </ul> </li> </ul> <p>Al definir estos m\u00e9todos de manera gen\u00e9rica, podemos reutilizar esta interfaz en cualquier clase de servicio que maneje entidades distintas, manteniendo as\u00ed la consistencia y reduciendo el c\u00f3digo duplicado.</p>"},{"location":"configuracion-entorno/#interfaz-ibookservice","title":"Interfaz IBookService","text":"<p>La interfaz <code>IBookService</code> extiende de <code>ICRUD</code> especificando que trabajar\u00e1 con la entidad <code>Book</code> y que el tipo de la clave primaria es <code>Integer</code>. Esto significa que <code>IBookService</code> hereda todos los m\u00e9todos de <code>ICRUD</code> para operar con entidades <code>Book</code>.</p> IBookService.java<pre><code>import com.geovannycode.model.Book;\n\npublic interface IBookService extends ICRUD&lt;Book, Integer&gt; {\n}\n</code></pre>"},{"location":"configuracion-entorno/#interfaz-iauthorservice","title":"Interfaz IAuthorService","text":"<p>Similar a <code>IBookService</code>, la interfaz <code>IAuthorService</code> extiende de <code>ICRUD</code>, especificando que trabajar\u00e1 con la entidad <code>Author</code> y que el tipo de la clave primaria es <code>Integer</code>. Al extender <code>ICRUD</code>, <code>IAuthorService</code> hereda todos los m\u00e9todos para operar con entidades <code>Author</code>.</p> IAuthorService.java<pre><code>import com.geovannycode.model.Author;\n\npublic interface IAuthorService extends ICRUD&lt;Author, Integer&gt; {\n}\n</code></pre> <p>Con las interfaces <code>IBookService</code> e <code>IAuthorService</code> creadas, estamos listos para implementar la l\u00f3gica en sus clases correspondientes <code>(BookServiceImpl y AuthorServiceImpl)</code> dentro de la subcarpeta <code>impl</code>.</p>"},{"location":"configuracion-entorno/#implementaciones-de-servicio","title":"Implementaciones de Servicio","text":"<p>Ambas clases (<code>AuthorServiceImpl</code> y <code>BookServiceImpl</code>) utilizan la anotaci\u00f3n <code>@Service</code>, lo que indica que son componentes de servicio en Spring, y estar\u00e1n disponibles como beans de Spring. Al implementar las interfaces de servicio (<code>IAuthorService</code> e <code>IBookService</code>), estas clases proporcionan la l\u00f3gica de negocio para cada operaci\u00f3n CRUD.</p>"},{"location":"configuracion-entorno/#uso-de-requiredargsconstructor","title":"Uso de <code>@RequiredArgsConstructor</code>","text":"<p>La anotaci\u00f3n <code>@RequiredArgsConstructor</code> de Lombok genera un constructor que inicializa los atributos <code>final</code>, en este caso, <code>IAuthorRepo</code> para <code>AuthorServiceImpl</code> e <code>IBookRepo</code> para <code>BookServiceImpl</code>. Esto permite la inyecci\u00f3n de dependencias de manera autom\u00e1tica, ya que Spring inyectar\u00e1 los repositorios necesarios al crear instancias de estas clases.</p> AuthorServiceImpl.java<pre><code>import com.geovannycode.model.Author;\nimport com.geovannycode.repo.IAuthorRepo;\nimport com.geovannycode.service.IAuthorService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\n@RequiredArgsConstructor\npublic class AuthorServiceImpl implements IAuthorService {\n\n    private final IAuthorRepo repo;\n\n    @Override\n    public Author save(Author author) throws Exception {\n        return repo.save(author);\n    }\n\n    @Override\n    public List&lt;Author&gt; saveAll(List&lt;Author&gt; list) throws Exception {\n        return repo.saveAll(list);\n    }\n\n    @Override\n    public Author update(Author author, Integer id) throws Exception {\n        if (repo.existsById(id)) {\n            author.setIdAuthor(id);\n            return repo.save(author);\n        }\n        throw new Exception(\"Author not found\");\n    }\n\n    @Override\n    public List&lt;Author&gt; findAll() throws Exception {\n        return repo.findAll();\n    }\n\n    @Override\n    public Author findById(Integer id) throws Exception {\n        return repo.findById(id).orElse(new Author());\n    }\n\n    @Override\n    public void delete(Integer id) throws Exception {\n        repo.deleteById(id);\n    }\n}\n</code></pre> <ul> <li>L\u00edneas 16: <code>save(Author author)</code> Guarda un nuevo autor en la base de datos.</li> <li>L\u00edneas 21: <code>saveAll(List&lt;Author&gt; list)</code> Guarda una lista de autores en la base de datos.</li> <li>L\u00edneas 26: <code>update(Author author, Integer id)</code> Actualiza un autor existente. Primero verifica si el autor existe en la base de datos (<code>existsById(id)</code>). Si existe, actualiza el autor con el ID proporcionado; si no, lanza una excepci\u00f3n.</li> <li>L\u00edneas 35: <code>findAll()</code> Devuelve todos los autores en la base de datos.</li> <li>L\u00edneas 40: <code>findById(Integer id)</code> Busca un autor por su ID. Si no se encuentra, devuelve un objeto Author vac\u00edo.</li> <li>L\u00edneas 45: <code>delete(Integer id)</code> Elimina un autor seg\u00fan su ID.</li> </ul> BookServiceImpl.java<pre><code>import com.geovannycode.model.Book;\nimport com.geovannycode.repo.IBookRepo;\nimport com.geovannycode.service.IBookService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\n@RequiredArgsConstructor\npublic class BookServiceImpl implements IBookService {\n\n    private final IBookRepo repo;\n\n    @Override\n    public Book save(Book book) throws Exception {\n        return repo.save(book);\n    }\n\n    @Override\n    public List&lt;Book&gt; saveAll(List&lt;Book&gt; list) throws Exception {\n        return repo.saveAll(list);\n    }\n\n    @Override\n    public Book update(Book book, Integer id) throws Exception {\n        if (repo.existsById(id)) {\n            book.setIdBook(id);\n            return repo.save(book);\n        }\n        throw new Exception(\"Book not found\");\n    }\n\n    @Override\n    public List&lt;Book&gt; findAll() throws Exception {\n        return repo.findAll();\n    }\n\n    @Override\n    public Book findById(Integer id) throws Exception {\n        return repo.findById(id).orElse(new Book());\n    }\n\n    @Override\n    public void delete(Integer id) throws Exception {\n        repo.deleteById(id);\n    }\n}\n</code></pre>"},{"location":"configuracion-entorno/#paso-8-paquete-controller","title":"Paso 8: Paquete controller","text":"<p>En la arquitectura MVC, la capa de controladores (o <code>controller</code>) es la que se encarga de recibir y manejar las solicitudes HTTP del cliente (como GET, POST, PUT, DELETE) y de devolver respuestas adecuadas. En este caso, implementaremos dos controladores: <code>AuthorController</code> y <code>BookController</code>, que gestionar\u00e1n las operaciones CRUD para los autores y libros, respectivamente.</p> <p>Ambos controladores est\u00e1n anotados con <code>@RestController</code>, lo que indica que son componentes de Spring MVC que procesan directamente las solicitudes HTTP y devuelven datos en formato JSON. Utilizamos <code>@RequestMapping</code> para definir el punto de entrada base para cada controlador (<code>/authors</code> y <code>/books</code>), y <code>@CrossOrigin</code> para permitir solicitudes CORS desde cualquier origen, lo cual es \u00fatil cuando el frontend y el backend est\u00e1n en diferentes dominios durante el desarrollo.</p> AuthorController.java<pre><code>import com.geovannycode.model.Author;\nimport com.geovannycode.service.IAuthorService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.net.URI;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/authors\")\n@RequiredArgsConstructor\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n    private final IAuthorService service;\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;Author&gt;&gt; findAll() throws Exception {\n        return ResponseEntity.ok(service.findAll());\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Author&gt; findById(@PathVariable(\"id\") Integer id) throws Exception {\n        return ResponseEntity.ok(service.findById(id));\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;Author&gt; save(@RequestBody Author author) throws Exception {\n        Author obj = service.save(author);\n        return ResponseEntity.created(URI.create(\"http://localhost:8080/authors/\" + obj.getIdAuthor())).body(obj);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;Author&gt; update(@RequestBody Author author, @PathVariable(\"id\") Integer id) throws Exception {\n        return ResponseEntity.ok(service.update(author, id));\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteById(@PathVariable(\"id\") Integer id) throws Exception {\n        service.delete(id);\n        return ResponseEntity.ok().build();\n    }\n}\n</code></pre> <ul> <li> <p>@GetMapping:</p> <ul> <li><code>findAll()</code>: Maneja las solicitudes GET en <code>/authors</code> y devuelve una lista de todos los autores en la base de datos.</li> <li><code>findById(Integer id)</code>: Maneja las solicitudes GET en <code>/authors/{id}</code> para obtener un autor por su ID.</li> </ul> </li> <li> <p>@PostMapping:</p> <ul> <li><code>save(Author author)</code>: Maneja las solicitudes POST en <code>/authors</code> para crear un nuevo autor.</li> </ul> </li> <li> <p>@PutMapping:</p> <ul> <li><code>update(Author author, Integer id)</code>: Maneja las solicitudes PUT en <code>/authors/{id}</code> para actualizar un autor existente. Si el autor se encuentra y se actualiza correctamente, devuelve la entidad actualizada.</li> </ul> </li> <li> <p>@DeleteMapping:</p> <ul> <li><code>deleteById(Integer id)</code>: Maneja las solicitudes DELETE en <code>/authors/{id}</code> para eliminar un autor por su ID. Retorna una respuesta vac\u00eda con c\u00f3digo 200 (OK) si la eliminaci\u00f3n es exitosa.</li> </ul> </li> </ul> BookController.java<pre><code>import com.geovannycode.model.Book;\nimport com.geovannycode.service.IBookService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.net.URI;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/books\")\n@RequiredArgsConstructor\n@CrossOrigin(origins = \"*\")\npublic class BookController {\n\n    private final IBookService service;\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;Book&gt;&gt; findAll() throws Exception {\n        return ResponseEntity.ok(service.findAll());\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Book&gt; findById(@PathVariable(\"id\") Integer id) throws Exception {\n        return ResponseEntity.ok(service.findById(id));\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;Book&gt; save(@RequestBody Book book) throws Exception {\n        Book obj = service.save(book);\n        return ResponseEntity.created(URI.create(\"http://localhost:8080/books/\" + obj.getIdBook())).body(obj);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity&lt;Book&gt; update(@RequestBody Book book, @PathVariable(\"id\") Integer id) throws Exception {\n        return ResponseEntity.ok(service.update(book, id));\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteById(@PathVariable(\"id\") Integer id) throws Exception {\n        service.delete(id);\n        return ResponseEntity.ok().build();\n    }\n}\n</code></pre>"},{"location":"configuracion-entorno/#explicaciones-adicionales","title":"Explicaciones Adicionales","text":"<ol> <li>ResponseEntity: <ul> <li>Utilizamos <code>ResponseEntity</code> para construir la respuesta HTTP con el estado adecuado, permitiendo personalizar el cuerpo y los encabezados de la respuesta. Por ejemplo, en el m\u00e9todo save, utilizamos <code>ResponseEntity.created(...)</code> para indicar que el recurso fue creado exitosamente.</li> </ul> </li> <li>@CrossOrigin(origins = \"*\"):<ul> <li>Esta anotaci\u00f3n permite solicitudes desde cualquier origen, lo cual es \u00fatil para habilitar CORS (Cross-Origin Resource Sharing) en aplicaciones de frontend que se ejecutan en diferentes dominios o puertos durante el desarrollo. Puede ser configurada para limitar el origen de las solicitudes en un ambiente de producci\u00f3n.</li> </ul> </li> <li>@PathVariable y @RequestBody:<ul> <li><code>@PathVariable</code> permite extraer variables de la URL, como el ID del autor o libro.</li> <li><code>@RequestBody</code> permite deserializar el cuerpo de la solicitud en un objeto Java. En este caso, se usa para recibir los datos de <code>Author</code> o <code>Book</code> en los m\u00e9todos <code>save</code> y <code>update</code>.</li> </ul> </li> </ol>"},{"location":"configuracion-entorno/#paso-9-crear-archivos-json-en-el-paquete-resourcesjson","title":"Paso 9: Crear Archivos JSON en el Paquete resources/json","text":"<p>Crea una carpeta llamada json dentro de <code>src/main/resources</code>, y luego agrega los archivos <code>authors.json</code> y <code>books.json</code> con el contenido proporcionado.</p> authors.json<pre><code>[\n  {\n    \"firstName\": \"Geovanny\",\n    \"lastName\": \"Mendoza\",\n    \"country\": \"Colombia\",\n    \"urlPhoto\": \"https://example.com/geovanny_photo.jpg\"\n  },\n  {\n    \"firstName\": \"Ot\u00e1vio\",\n    \"lastName\": \"Santana\",\n    \"country\": \"Brasil\",\n    \"urlPhoto\": \"https://example.com/otavio_photo.jpg\"\n  }\n]\n</code></pre> books.json<pre><code>[\n  {\n    \"name\": \"Building Modern Web Applications With JakartaEE\",\n    \"review\": \"Gu\u00eda para crear aplicaciones modernas con JakartaEE, bases de datos NoSQL, MicroProfile y Vaadin.\",\n    \"author\": { \"idAuthor\": 1 },\n    \"urlCover\": \"https://example.com/building_modern_apps_cover.jpg\",\n    \"enabled\": true\n  },\n  {\n    \"name\": \"Mastering the Java Virtual Machine\",\n    \"review\": \"Gu\u00eda sobre el funcionamiento interno de la JVM, gesti\u00f3n de memoria y optimizaci\u00f3n del rendimiento.\",\n    \"author\": { \"idAuthor\": 2 },\n    \"urlCover\": \"https://example.com/mastering_jvm_cover.jpg\",\n    \"enabled\": true\n  }\n]\n</code></pre> <p>Estos archivos JSON contienen los datos iniciales de <code>Author</code> y <code>Book</code> que se cargar\u00e1n autom\u00e1ticamente en la base de datos cuando se inicie la aplicaci\u00f3n.</p>"},{"location":"configuracion-entorno/#paso-10-configuracion-del-archivo-applicationyml","title":"Paso 10: Configuraci\u00f3n del Archivo <code>application.yml</code>","text":"<p>En el archivo <code>application.yml</code>, ubicado en <code>src/main/resources</code>, agrega la siguiente configuraci\u00f3n para establecer las propiedades de JPA y la clave API de OpenAI.</p> application.yml<pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: create\n    generate-ddl: true\n    database-platform: org.hibernate.dialect.PostgreSQLDialect\n  ai:\n    openai:\n      api-key: SPRING_AI_OPENAI_API_KEY\n</code></pre> <ul> <li>L\u00edneas 1-4: <code>spring.jpa.hibernate.ddl-auto create</code> Esta propiedad le indica a Hibernate que cree las tablas en la base de datos autom\u00e1ticamente al iniciar la aplicaci\u00f3n.</li> <li>L\u00edneas 6: <code>database-platform org.hibernate.dialect.PostgreSQLDialect</code> Especifica el dialecto de PostgreSQL para que Hibernate sepa c\u00f3mo interactuar correctamente con la base de datos.</li> <li>L\u00edneas 7-9: <code>ai.openai.api-key</code> Configura la clave API para acceder a los servicios de OpenAI. Reemplaza <code>SPRING_AI_OPENAI_API_KEY</code> con tu clave API de OpenAI.</li> </ul>"},{"location":"configuracion-entorno/#paso-11-actualizar-la-clase-springaiapplication","title":"Paso 11: Actualizar la Clase SpringaiApplication","text":"<p>La clase <code>SpringaiApplication</code> debe implementar <code>ApplicationRunner</code> para cargar los datos de authors.json y books.json al inicio de la aplicaci\u00f3n.</p> SpringaiApplication.java<pre><code>import com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.geovannycode.model.Author;\nimport com.geovannycode.model.Book;\nimport com.geovannycode.service.IAuthorService;\nimport com.geovannycode.service.IBookService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.util.FileCopyUtils;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\n\n@SpringBootApplication\n@RequiredArgsConstructor\npublic class SpringaiApplication implements ApplicationRunner {\n\n    private final ResourceLoader resourceLoader;\n    private final IAuthorService authorService;\n    private final IBookService bookService;\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringaiApplication.class, args);\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        Resource resource1 = resourceLoader.getResource(\"classpath:json/authors.json\");\n        Resource resource2 = resourceLoader.getResource(\"classpath:json/books.json\");\n\n        // Leer el contenido del archivo JSON\n        byte[] jsonData1 = FileCopyUtils.copyToByteArray(resource1.getInputStream());\n        byte[] jsonData2 = FileCopyUtils.copyToByteArray(resource2.getInputStream());\n\n        String jsonString1 = new String(jsonData1, StandardCharsets.UTF_8);\n        String jsonString2 = new String(jsonData2, StandardCharsets.UTF_8);\n\n        // Usar Jackson para convertir el JSON a objetos Java\n        ObjectMapper objectMapper = new ObjectMapper();\n        List&lt;Author&gt; authors = objectMapper.readValue(jsonString1, new TypeReference&lt;List&lt;Author&gt;&gt;(){});\n        List&lt;Book&gt; books = objectMapper.readValue(jsonString2, new TypeReference&lt;List&lt;Book&gt;&gt;(){});\n\n        // Guardar los datos en la base de datos\n        authorService.saveAll(authors);\n        bookService.saveAll(books);\n    }\n}\n</code></pre> <ul> <li>L\u00edneas 19:<code>@SpringBootApplication</code> Anota la clase principal como una aplicaci\u00f3n Spring Boot.</li> <li>L\u00edneas 19: <code>@RequiredArgsConstructor</code> Genera un constructor para inyectar las dependencias ResourceLoader, IAuthorService, e <code>IBookService</code>.</li> <li>L\u00edneas 19: <code>run(ApplicationArguments args)</code> Este m\u00e9todo se ejecuta al iniciar la aplicaci\u00f3n.</li> <li>L\u00edneas 19: <code>Cargar archivos JSON</code> Usa ResourceLoader para obtener los archivos <code>authors.json</code> y <code>books.json</code>.</li> <li>L\u00edneas 19: <code>Leer el contenido</code> Utiliza <code>FileCopyUtils</code> para leer el contenido de los archivos JSON en <code>byte[]</code> y luego los convierte a <code>String</code>.</li> <li>L\u00edneas 19: <code>Convertir JSON a objetos Java</code> Usa <code>ObjectMapper</code> de Jackson para convertir el JSON en listas de objetos <code>Author</code> y <code>Book</code>.</li> <li>L\u00edneas 19: <code>Guardar en la base de datos</code> Utiliza <code>authorService</code> y <code>bookService</code> para guardar los datos en la base de datos.</li> </ul>"},{"location":"configuracion-entorno/#paso-12-archivo-docker-composeyml","title":"Paso 12: Archivo <code>docker-compose.yml</code>","text":"<p>Este archivo utiliza la configuraci\u00f3n de Docker Compose para iniciar un servicio de base de datos PostgreSQL en un contenedor. Con este archivo, puedes levantar el contenedor de PostgreSQL con solo un comando, lo que simplifica el manejo del entorno de desarrollo y asegura que todos los colaboradores del proyecto tengan una configuraci\u00f3n consistente.</p> docker-compose.yml<pre><code>version: \"3.8\"\nservices:\n  postgres_db:\n    container_name: \"postgres_db\"\n    image: \"postgres\"\n    env_file: ./.env\n    ports:\n      - ${DB_LOCAL_PORT}:${DB_DOCKER_PORT}\n    environment:\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_DB: ${POSTGRES_DB}\n    volumes:\n      - postgres-data:${DB_VOLUME_URL}\n\nvolumes:\n  postgres-data:\n</code></pre>"},{"location":"configuracion-entorno/#explicacion-de-la-configuracion","title":"Explicaci\u00f3n de la Configuraci\u00f3n","text":"<ul> <li> <p><code>version: \"3.8\"</code>: Especifica la versi\u00f3n de Docker Compose. La versi\u00f3n 3.8 es compatible con las \u00faltimas caracter\u00edsticas de Docker.</p> </li> <li> <p><code>services</code>: Define los servicios que Docker Compose gestionar\u00e1. En este caso, tenemos solo un servicio postgres_db para PostgreSQL.</p> </li> <li> <p><code>postgres_db</code>:</p> <ul> <li><code>container_name</code>: Nombre del contenedor. Esto facilita la identificaci\u00f3n del contenedor en la lista de contenedores activos.</li> <li><code>image</code>: Especifica la imagen de Docker que se utilizar\u00e1. En este caso, <code>postgres</code> se descargar\u00e1 de Docker Hub.</li> <li><code>env_file</code>: Carga variables de entorno desde un archivo <code>.env</code> ubicado en la ra\u00edz del proyecto. Este archivo debe contener las credenciales de la base de datos y otros detalles de configuraci\u00f3n.</li> <li><code>ports</code>: Mapea el puerto de PostgreSQL en el contenedor (<code>DB_DOCKER_PORT</code>) a un puerto en la m\u00e1quina local (<code>DB_LOCAL_PORT</code>). Esto permite acceder a la base de datos desde la m\u00e1quina host.</li> <li><code>environment</code>: Define variables de entorno adicionales espec\u00edficas del servicio, como el nombre de usuario, la contrase\u00f1a y el nombre de la base de datos.</li> <li><code>volumes</code>: Monta un volumen persistente (<code>postgres-data</code>) en el contenedor, mapeado al directorio especificado en <code>DB_VOLUME_URL</code> (ubicado en el archivo <code>.env</code>). Esto asegura que los datos de la base de datos se mantengan incluso si el contenedor se reinicia o elimina.</li> </ul> </li> <li><code>volumes</code>: Define el volumen <code>postgres-data</code> para la persistencia de datos, lo que permite que la informaci\u00f3n almacenada en PostgreSQL persista entre reinicios de contenedores.</li> </ul>"},{"location":"configuracion-entorno/#descarga-del-proyecto-base","title":"Descarga del Proyecto Base","text":"<p>Para facilitar el inicio del taller y omitir la configuraci\u00f3n inicial del entorno, puedes descargar el proyecto base desde el repositorio de GitHub en la rama <code>01_Structure_Project</code>. Esto te permitir\u00e1 comenzar directamente con el c\u00f3digo y la estructura b\u00e1sica del proyecto ya configurados.</p> <p>Puedes acceder al proyecto en la siguiente URL:</p> <p>\ud83d\udd17 Ejemplo SpringAI</p> <p>Esta rama incluye toda la estructura inicial del proyecto, permiti\u00e9ndote enfocarte en el desarrollo de las funcionalidades de IA generativa sin preocuparte por la configuraci\u00f3n b\u00e1sica del entorno.</p>"},{"location":"image-model/","title":"Image Model","text":""},{"location":"image-model/#contexto-de-dall-e-en-openai","title":"Contexto de DALL-E en OpenAI","text":"<p>DALL-E es un modelo de generaci\u00f3n de im\u00e1genes desarrollado por OpenAI que permite crear im\u00e1genes a partir de descripciones textuales. En este proyecto, utilizamos la versi\u00f3n DALL-E 3, que se caracteriza por su alta calidad y capacidad para comprender descripciones complejas. La integraci\u00f3n con Spring AI permite que DALL-E se use como un servicio de generaci\u00f3n de im\u00e1genes en aplicaciones de Java.</p>"},{"location":"image-model/#paso-1-controlador-imagecontroller","title":"Paso 1: Controlador ImageController","text":"<p>El controlador <code>ImageController</code> expone un endpoint que permite generar una imagen a partir de una descripci\u00f3n textual.</p> FunctionConfig.java<pre><code>@RestController\n@RequestMapping(\"/images\")\n@RequiredArgsConstructor\n@CrossOrigin(origins = \"*\")\npublic class ImageController {\n\n    private final OpenAiImageModel openAiImageModel;\n\n    @GetMapping(\"/generate\")\n    public ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; generateImage(@RequestParam(\"param\") String param) {\n        ImageResponse imageResponse = openAiImageModel.call(new ImagePrompt(param,\n                OpenAiImageOptions.builder()\n                        .withModel(\"dall-e-3\")\n                        .withQuality(\"hd\")\n                        .withN(1) //cantidad de imagenes a generar, dall-e-3 solo permite n=1\n                        .withHeight(1024)\n                        .withWidth(1024)\n                        .build()\n        ));\n\n        String url = imageResponse.getResult().getOutput().getUrl();\n\n        return ResponseEntity.ok(new ResponseDTO&lt;&gt;(200, \"success\", url));\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1 <code>@RestController</code>: Define que esta clase es un controlador de Spring que manejar\u00e1 solicitudes HTTP y devolver\u00e1 respuestas en formato JSON.</p> </li> <li> <p>L\u00ednea 2 <code>@RequestMapping(\"/images\")</code>: Define la ruta base del controlador como /images. Todas las rutas dentro de este controlador estar\u00e1n bajo esta URL base.</p> </li> <li> <p>L\u00ednea 3 <code>@RequiredArgsConstructor</code>: Genera un constructor que inicializa los campos final en la clase. En este caso, inyecta OpenAiImageModel, que representa el modelo de generaci\u00f3n de im\u00e1genes de OpenAI.</p> </li> <li> <p>L\u00ednea 4 <code>@CrossOrigin(origins = \"*\")</code>: Permite que cualquier origen realice solicitudes a este controlador. Es \u00fatil para aplicaciones de frontend que se ejecutan en dominios diferentes.</p> </li> <li> <p>L\u00ednea 9 <code>@GetMapping(\"/generate\")</code>: Define el endpoint /images/generate, que responder\u00e1 a solicitudes GET. Este endpoint generar\u00e1 una imagen basada en una descripci\u00f3n proporcionada por el usuario.</p> </li> <li> <p>L\u00ednea 10 <code>public ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; generateImage(@RequestParam(\"param\") String param)</code>: M\u00e9todo que toma un par\u00e1metro de consulta param (la descripci\u00f3n de la imagen) y devuelve una respuesta JSON con la URL de la imagen generada.</p> </li> <li> <p>L\u00ednea 11 </p> <ul> <li><code>openAiImageModel.call(...)</code>: Llama al modelo de generaci\u00f3n de im\u00e1genes con los par\u00e1metros especificados.</li> <li><code>new ImagePrompt(param, ...)</code>: Crea un ImagePrompt, que contiene la descripci\u00f3n de la imagen (param) y las opciones de generaci\u00f3n.</li> </ul> </li> <li> <p>L\u00edneas 12-17 <code>OpenAiImageOptions.builder()</code>: Configura las opciones de generaci\u00f3n de la imagen:</p> <ul> <li><code>withModel(\"dall-e-3\")</code>: Especifica que se usar\u00e1 el modelo dall-e-3.</li> <li><code>withQuality(\"hd\")</code>: Configura la calidad de la imagen en \"hd\" (alta definici\u00f3n).</li> <li><code>withN(1)</code>: DALL-E solo permite generar una imagen por solicitud, as\u00ed que n=1.</li> <li><code>withHeight(1024) y withWidth(1024)</code>: Define el tama\u00f1o de la imagen como 1024x1024 p\u00edxeles.</li> </ul> </li> <li> <p>L\u00ednea 21 <code>String url = imageResponse.getResult().getOutput().getUrl();</code>: Extrae la URL de la imagen generada de la respuesta.</p> </li> <li>L\u00ednea 23 <code>return ResponseEntity.ok(new ResponseDTO&lt;&gt;(200, \"success\", url));</code>: Devuelve una respuesta con estado HTTP 200 y un ResponseDTO que contiene la URL de la imagen generada.</li> </ul>"},{"location":"image-model/#paso-2-integracion-en-vaadin-image-model","title":"Paso 2: Integraci\u00f3n en Vaadin <code>Image Model</code>","text":"<p>Este formulario como se puede observar en la figura #1 es de generaci\u00f3n de im\u00e1genes, por lo cual permite al usuario ingresar una descripci\u00f3n en texto y, al hacer clic en \"Generate Image\", se env\u00eda una solicitud al backend. El backend procesa esta solicitud con DALL-E y devuelve una URL de la imagen generada, que se muestra autom\u00e1ticamente en el contenedor de la interfaz.</p> <p></p> <p>Figura #1: Formulario de Generaci\u00f3n de Image</p>"},{"location":"image-model/#paso-21-creacion-de-formulario-en-vaadin","title":"Paso 2.1: Creaci\u00f3n de Formulario en Vaadin","text":"ImageGeneratorView.java<pre><code>@Route(\"image-generator\")\n@Menu(title = \"Image Model\", order = 3)\npublic class ImageGeneratorView extends VerticalLayout {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n    private final String backendUrl = \"http://localhost:8080/images/generate\";\n\n    public ImageGeneratorView() {\n        setSizeFull();\n\n        // Campo de texto para ingresar la descripci\u00f3n de la imagen\n        TextArea descriptionInput = new TextArea(\"Enter image description:\");\n        descriptionInput.setWidth(\"400px\");\n\n        // Bot\u00f3n para generar la imagen\n        Button generateButton = new Button(\"Generate Image\");\n\n        // Contenedor de la imagen\n        Image imageDisplay = new Image();\n        imageDisplay.setWidth(\"400px\"); // Ajusta el ancho de la imagen\n        imageDisplay.setHeight(\"400px\");\n\n        generateButton.addClickListener(click -&gt; {\n            String description = descriptionInput.getValue();\n            String url = backendUrl + \"?param=\" + description;\n\n            // Llamada al backend para obtener la URL de la imagen\n            ResponseEntity&lt;ResponseDTO&lt;String&gt;&gt; responseEntity = restTemplate.exchange(\n                    url,\n                    HttpMethod.GET,\n                    null,\n                    new ParameterizedTypeReference&lt;ResponseDTO&lt;String&gt;&gt;() {}\n            );\n\n            if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {\n                String imageUrl = responseEntity.getBody().getData(); // URL de la imagen generada\n                imageDisplay.setSrc(imageUrl); // Mostrar la imagen en el componente Image\n            } else {\n                Notification.show(\"Error: Failed to generate image.\");\n            }\n        });\n\n        add(descriptionInput, generateButton, imageDisplay);\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1 <code>@Route(\"image-generator\")</code>: Define la ruta de esta vista como /image-generator. Esto permite acceder a la vista a trav\u00e9s de esta URL.</p> </li> <li> <p>L\u00ednea 2 <code>@Menu(title = \"Image Model\", order = 3)</code>: A\u00f1ade esta vista al men\u00fa lateral con el t\u00edtulo \"Image Model\" y la coloca en la tercera posici\u00f3n.</p> </li> <li> <p>L\u00ednea 3 <code>public class ImageGeneratorView extends VerticalLayout</code>: La clase ImageGeneratorView extiende VerticalLayout de Vaadin, que permite organizar los componentes en una disposici\u00f3n vertical.</p> </li> <li> <p>L\u00ednea 5 <code>RestTemplate restTemplate</code>: Cliente de Spring para hacer solicitudes HTTP al backend.</p> </li> <li> <p>L\u00ednea 6 <code>String backendUrl</code>: Define la URL del endpoint en el backend (<code>/images/generate</code>) al que se enviar\u00e1n las solicitudes para generar la imagen.</p> </li> <li> <p>L\u00ednea 9 <code>setSizeFull()</code>: Configura el dise\u00f1o para ocupar todo el espacio disponible en la ventana.</p> </li> <li> <p>L\u00ednea 12 <code>TextArea descriptionInput</code>: Campo de entrada donde el usuario puede escribir la descripci\u00f3n de la imagen que desea generar.</p> </li> <li> <p>L\u00ednea 13 <code>descriptionInput.setWidth(\"400px\")</code>: Establece el ancho del campo de texto en 400 p\u00edxeles para mejorar la experiencia visual del usuario.</p> </li> <li> <p>L\u00ednea 16 <code>Button generateButton</code>: Bot\u00f3n que, al hacer clic, iniciar\u00e1 el proceso de generaci\u00f3n de la imagen llamando al backend.</p> </li> <li> <p>L\u00ednea 19 <code>Image imageDisplay</code>: Componente de Vaadin para mostrar la imagen generada.</p> </li> <li> <p>L\u00edneas 20-21 <code>imageDisplay.setWidth(\"400px\") y imageDisplay.setHeight(\"400px\")</code>: Configura el tama\u00f1o del contenedor de la imagen en 400x400 p\u00edxeles para que la imagen generada se ajuste visualmente al espacio asignado.</p> </li> <li> <p>L\u00edneas 23-25 <code>generateButton.addClickListener</code>: Define la acci\u00f3n que ocurre al hacer clic en el bot\u00f3n \"Generate Image\".</p> <ul> <li><code>descriptionInput.getValue()</code>: Obtiene la descripci\u00f3n ingresada por el usuario.</li> <li><code>url</code>: Construye la URL de la solicitud al backend, agregando el par\u00e1metro param con la descripci\u00f3n de la imagen.</li> </ul> </li> <li> <p>L\u00edneas 28-32 </p> <ul> <li><code>restTemplate.exchange(...)</code>: Realiza una solicitud GET al backend para obtener la URL de la imagen generada.</li> <li><code>new ParameterizedTypeReference&lt;ResponseDTO&lt;String&gt;&gt;() {}</code>: Permite manejar la respuesta como un ResponseDTO con un String que contiene la URL de la imagen.</li> </ul> </li> <li> <p>L\u00ednea 35-40 <code>Validaci\u00f3n de la Respuesta</code>:</p> <ul> <li>Verifica que la respuesta sea exitosa (<code>2xx</code>) y que el cuerpo de la respuesta no sea nulo.</li> <li><code>String imageUrl = responseEntity.getBody().getData();</code>: Extrae la URL de la imagen generada.</li> <li><code>imageDisplay.setSrc(imageUrl);</code>: Establece la URL de la imagen en el componente imageDisplay, lo que hace que la imagen se cargue y muestre en la interfaz.</li> <li>Si la solicitud falla, se muestra una notificaci\u00f3n de error al usuario.</li> </ul> </li> <li> <p>L\u00ednea 43 <code>add(descriptionInput, generateButton, imageDisplay);</code>: A\u00f1ade los componentes (<code>descriptionInput</code>, <code>generateButton</code>, y <code>imageDisplay</code>) a la vista para que se muestren en la interfaz.</p> </li> </ul>"},{"location":"image-model/#resumen","title":"Resumen","text":"<ul> <li>ImageController: Generar im\u00e1genes basadas en descripciones textuales, lo que resulta \u00fatil para crear contenido visual personalizado a partir de texto. Utilizando DALL-E, el controlador convierte cualquier descripci\u00f3n en una imagen de alta calidad que se puede mostrar en la interfaz de usuario.</li> </ul> <p>La integraci\u00f3n de Vaadin como interfaz de frontend permite a los usuarios interactuar de forma sencilla y visual con estas funcionalidades de IA. Con Vaadin, se crean formularios din\u00e1micos para ingresar descripciones de im\u00e1genes y cargar im\u00e1genes, lo que mejora la experiencia de usuario al permitir la visualizaci\u00f3n instant\u00e1nea de los resultados generados por DALL-E. Esta combinaci\u00f3n entre DALL-E, el modelo de chat de OpenAI, Spring AI y Vaadin demuestra c\u00f3mo se pueden utilizar modelos avanzados de IA en aplicaciones interactivas y visuales, integrando tanto procesamiento de texto como de imagen para crear aplicaciones enriquecidas y centradas en el usuario.</p>"},{"location":"multimodality/","title":"Multi Modality","text":"<p>La multimodalidad permite que los modelos de IA procesen y generen contenido basado en diferentes tipos de datos, como texto e im\u00e1genes, y los combinen para proporcionar respuestas complejas y enriquecidas. En este caso, el modelo puede interpretar una imagen cargada, generar una descripci\u00f3n textual sobre lo que contiene y luego producir una caricatura en base a esa descripci\u00f3n. La capacidad de analizar y generar contenido a partir de m\u00faltiples modalidades (texto e imagen) demuestra el potencial de la IA para realizar tareas m\u00e1s avanzadas y sofisticadas que responden a interacciones humanas complejas.</p>"},{"location":"multimodality/#paso-1-controlador-multimodalitycontroller","title":"Paso 1: Controlador MultiModalityController","text":"<p>Este controlador permite realizar an\u00e1lisis multimodal. El usuario carga una imagen, el modelo describe su contenido, y luego se genera una caricatura basada en esa descripci\u00f3n.</p> MultiModalityController.java<pre><code>@RestController\n@RequestMapping(\"/multis\")\n@RequiredArgsConstructor\npublic class MultiModalityController {\n\n    private final OpenAiChatModel openAiChatModel;\n    private final OpenAiImageModel openAiImageModel;\n\n    @PostMapping(\"/upload\")\n    public String multiModalityUpload(@RequestParam(\"image\") MultipartFile imageFile) throws Exception{\n        UserMessage userMessage = new UserMessage(\n                \"Explicame que ves en esta imagen?\",\n                List.of(new Media(MimeTypeUtils.IMAGE_JPEG, new ByteArrayResource(imageFile.getBytes())))\n        );\n\n        ChatResponse response = openAiChatModel.call(new Prompt(List.of(userMessage)));\n        String description = response.getResult().getOutput().getContent();\n\n        String url = openAiImageModel.call(new ImagePrompt(\"Generame una caricatura de esta descripcion: \" + description,\n                OpenAiImageOptions.builder()\n                        .withModel(\"dall-e-3\")\n                        .withQuality(\"standard\")\n                        .withN(1)\n                        .withHeight(1024)\n                        .withWidth(1024)\n                        .build()\n        )).getResult().getOutput().getUrl();\n\n        return url;\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1 <code>@RestController</code>: Define el controlador como un manejador de solicitudes HTTP en formato JSON.</p> </li> <li> <p>L\u00ednea 2 <code>@RequestMapping(\"/multis\")</code>: Define la ruta base del controlador como /multis.</p> </li> <li> <p>L\u00ednea 3 <code>@RequiredArgsConstructor</code>: Genera un constructor que inyecta OpenAiChatModel y OpenAiImageModel.</p> </li> <li> <p>L\u00ednea 9 <code>@GetMapping(\"/upload\")</code>: Define el endpoint /multis/upload, que responder\u00e1 a solicitudes GET para procesar im\u00e1genes.</p> </li> <li> <p>L\u00ednea 10 <code>public String multiModalityUpload(@RequestParam(\"image\") MultipartFile imageFile) throws Exception</code>: M\u00e9todo que toma una imagen como entrada y devuelve la URL de la caricatura generada.</p> </li> <li> <p>L\u00ednea 11 <code>new UserMessage(...)</code>: Crea un mensaje de usuario pidiendo al modelo que describa el contenido de la imagen cargada.</p> </li> <li> <p>L\u00ednea 13 </p> <ul> <li><code>List.of(new Media(...))</code>: Adjunta la imagen cargada como un recurso (Media) en formato JPEG.</li> <li><code>new ByteArrayResource(imageFile.getBytes())</code>: Convierte el archivo de imagen en un recurso de bytes para enviarlo al modelo.</li> </ul> </li> <li> <p>L\u00ednea 16 <code>openAiChatModel.call(...)</code>: Llama al modelo de chat para procesar el mensaje del usuario y obtener una descripci\u00f3n de la imagen.</p> </li> <li> <p>L\u00ednea 17 <code>String description = response.getResult().getOutput().getContent();</code>: Extrae la descripci\u00f3n generada por el modelo a partir de la imagen cargada.</p> </li> <li> <p>L\u00ednea 19 </p> <ul> <li><code>openAiImageModel.call(...)</code>: Llama nuevamente al modelo de generaci\u00f3n de im\u00e1genes para crear una caricatura basada en la descripci\u00f3n obtenida.</li> <li><code>new ImagePrompt(\"Generame una caricatura de esta descripcion: \" + description, ...)</code>: Crea un ImagePrompt con la descripci\u00f3n generada en el paso anterior.</li> </ul> </li> <li> <p>L\u00edneas 21-25 <code>withModel(\"dall-e-3\"), withQuality(\"standard\"), withN(1), withHeight(1024), withWidth(1024)</code>: Configura las opciones para la generaci\u00f3n de la caricatura, similar al controlador anterior.</p> </li> <li> <p>L\u00ednea 27 <code>getResult().getOutput().getUrl()</code>: Obtiene la URL de la caricatura generada.</p> </li> <li> <p>L\u00ednea 29 <code>return url;</code>: Devuelve la URL de la caricatura generada como respuesta.</p> </li> </ul>"},{"location":"multimodality/#paso-2-integracion-en-vaadin-multimodality","title":"Paso 2: Integraci\u00f3n en Vaadin <code>MultiModality</code>","text":"<p>Este formulario permite a los usuarios cargar una imagen y recibir una descripci\u00f3n generada autom\u00e1ticamente por la IA, junto con una caricatura basada en esa descripci\u00f3n. La interfaz est\u00e1 compuesta por varios elementos clave que gu\u00edan al usuario a lo largo del proceso de carga y visualizaci\u00f3n del contenido generado:</p> <ul> <li>Campo de Carga de Imagen: El usuario puede arrastrar y soltar una imagen o hacer clic en el bot\u00f3n \"Upload File...\" para seleccionar una imagen desde su dispositivo. Solo se aceptan im\u00e1genes en formato JPEG o PNG, con un tama\u00f1o m\u00e1ximo de 5 MB.</li> <li>\u00c1rea de Descripci\u00f3n Generada: Una vez cargada y procesada la imagen, se muestra aqu\u00ed una breve descripci\u00f3n generada por el modelo de IA sobre el contenido de la imagen. Esta \u00e1rea est\u00e1 configurada como solo lectura, permitiendo que el usuario visualice la descripci\u00f3n sin editarla.</li> <li>Visualizaci\u00f3n de la Caricatura Generada: La IA crea una caricatura basada en la descripci\u00f3n de la imagen original. Esta caricatura se presenta en la parte inferior del formulario, ofreciendo al usuario una versi\u00f3n ilustrada y estilizada del contenido.</li> <li>Interactividad: Despu\u00e9s de cargar una imagen, el sistema env\u00eda la imagen al backend, donde es procesada por el modelo de IA. La IA primero analiza la imagen para generar una descripci\u00f3n y, a partir de esa descripci\u00f3n, crea una caricatura que se devuelve y se muestra al usuario en la interfaz.</li> <li>Experiencia de Usuario: Este formulario est\u00e1 dise\u00f1ado para ser intuitivo, guiando al usuario paso a paso en la carga y visualizaci\u00f3n de la imagen y sus resultados. Cada componente est\u00e1 dispuesto en un dise\u00f1o vertical que mantiene la interfaz limpia y f\u00e1cil de usar. Como se muestra en la Figura #1, el formulario permite a los usuarios interactuar con las capacidades de la IA de manera visual, obteniendo un an\u00e1lisis descriptivo y una caricatura de la imagen subida.</li> </ul> <p></p> <p>Figura #1: Formulario de Generaci\u00f3n de Image</p> MultiModalityView.java<pre><code>@Route(\"image-analyzer\")\n@Menu(title = \"Image Analyzer\", order = 4)\npublic class MultiModalityView extends VerticalLayout {\n    private final RestTemplate restTemplate = new RestTemplate();\n    private final String backendUrl = \"http://localhost:8080/multis/upload\";\n\n    public MultiModalityView() {\n        setSizeFull();\n\n        // Componente para la carga de imagen\n        Upload upload = new Upload();\n        upload.setMaxFiles(1);\n        upload.setAcceptedFileTypes(\"image/jpeg\", \"image/png\");\n        upload.setMaxFileSize(5 * 1024 * 1024); // L\u00edmite de 5 MB para la imagen\n\n        // Contenedor de bytes para almacenar la imagen cargada\n        ByteArrayOutputStream uploadBuffer = new ByteArrayOutputStream();\n\n        upload.setReceiver((fileName, mimeType) -&gt; {\n            uploadBuffer.reset();\n            return uploadBuffer;\n        });\n\n        Image imageDisplay = new Image();\n        imageDisplay.setWidth(\"400px\");\n        imageDisplay.setHeight(\"400px\");\n\n        TextArea descriptionArea = new TextArea(\"Generated Description:\");\n        descriptionArea.setWidth(\"400px\");\n        descriptionArea.setHeight(\"100px\");\n        descriptionArea.setReadOnly(true);\n\n        upload.addSucceededListener(event -&gt; {\n            try {\n                HttpHeaders headers = new HttpHeaders();\n                headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n                MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();\n                body.add(\"image\", new ByteArrayResource(uploadBuffer.toByteArray()) {\n                    @Override\n                    public String getFilename() {\n                        return event.getFileName();\n                    }\n                });\n\n                HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(body, headers);\n\n                // Env\u00eda la solicitud POST al backend\n                ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(backendUrl, requestEntity, String.class);\n\n                if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {\n                    String imageUrl = responseEntity.getBody();\n                    imageDisplay.setSrc(imageUrl);\n                    descriptionArea.setValue(\"La IA gener\u00f3 la caricatura basada en la descripci\u00f3n.\");\n                } else {\n                    Notification.show(\"Error: Failed to analyze image.\");\n                }\n            } catch (Exception e) {\n                Notification.show(\"Error: \" + e.getMessage());\n            }\n        });\n\n        add(upload, descriptionArea, imageDisplay);\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>@Route(\"image-analyzer\")</code>: Define la ruta en la aplicaci\u00f3n para acceder a esta vista. Aqu\u00ed, el usuario acceder\u00e1 a esta funcionalidad en la URL <code>/image-analyzer</code>.</li> <li>L\u00ednea 2 <code>@Menu(title = \"Image Analyzer\", order = 4)</code>: Agrega la vista al men\u00fa de navegaci\u00f3n de la aplicaci\u00f3n con el t\u00edtulo \"Image Analyzer\" y la posiciona en el cuarto lugar.</li> <li>L\u00ednea 3 <code>public class MultiModalityView extends VerticalLayout</code>: Declara la clase MultiModalityView, que extiende VerticalLayout de Vaadin, para organizar los componentes verticalmente.</li> <li>L\u00ednea 4 <code>RestTemplate restTemplate</code>: Instancia de RestTemplate para realizar llamadas HTTP al backend.</li> <li>L\u00ednea 5 <code>backendUrl</code>: URL del endpoint del backend para cargar y analizar la imagen.</li> <li>L\u00ednea 7 <code>public MultiModalityView()</code>: Constructor de la clase donde se inicializan los componentes de la vista.</li> <li>L\u00ednea 8 <code>setSizeFull()</code>: Configura el tama\u00f1o de la vista para que ocupe todo el espacio disponible.</li> <li>L\u00ednea 11 <code>Upload upload = new Upload()</code>: Crea un componente Upload para que el usuario pueda cargar una imagen.</li> <li>L\u00ednea 12 <code>upload.setMaxFiles(1)</code>: Limita la cantidad de archivos que se pueden cargar a uno solo.</li> <li>L\u00ednea 13 <code>upload.setAcceptedFileTypes(\"image/jpeg\", \"image/png\")</code>: Especifica los tipos de archivos aceptados: JPEG y PNG.</li> <li>L\u00ednea 14 <code>upload.setMaxFileSize(5 * 1024 * 1024)</code>: Limita el tama\u00f1o m\u00e1ximo del archivo a 5 MB.</li> <li>L\u00ednea 17 <code>uploadBuffer</code>: Almacena temporalmente el archivo de imagen cargado en memoria para enviarlo al backend.</li> <li>L\u00ednea 19 <code>upload.setReceiver(...)</code>: Configura el receptor para el archivo cargado. Cada vez que se carga una imagen, se borra el contenido de uploadBuffer y se usa para almacenar el nuevo archivo.</li> <li>L\u00ednea 24 <code>Image imageDisplay = new Image()</code>: Crea un componente Image que se usar\u00e1 para mostrar la imagen generada por el backend.</li> <li>L\u00ednea 25 <code>imageDisplay.setWidth(\"400px\")</code>: Configura el ancho de la imagen a 400 p\u00edxeles.</li> <li> <p>L\u00ednea 26 <code>imageDisplay.setHeight(\"400px\")</code>: Configura la altura de la imagen a 400 p\u00edxeles.</p> </li> <li> <p>L\u00ednea 28 <code>TextArea descriptionArea</code>: Crea un \u00e1rea de texto para mostrar la descripci\u00f3n generada por el modelo de IA sobre el contenido de la imagen.</p> </li> <li>L\u00ednea 31 <code>descriptionArea.setReadOnly(true)</code>: Configura el \u00e1rea de texto como solo lectura para que el usuario no pueda editar la descripci\u00f3n generada.</li> <li>L\u00ednea 33 <code>upload.addSucceededListener(...)</code>: Agrega un SucceededListener que se ejecuta despu\u00e9s de que se carga correctamente el archivo.</li> <li>L\u00ednea 35 <code>HttpHeaders headers</code>: Crea encabezados HTTP para la solicitud.</li> <li> <p>L\u00ednea 36 <code>headers.setContentType(...)</code>: Establece el tipo de contenido como multipart/form-data para enviar el archivo al backend.</p> </li> <li> <p>L\u00ednea 38 <code>MultiValueMap&lt;String, Object&gt; body</code>: Crea un mapa de valores para almacenar el contenido de la solicitud.</p> </li> <li>L\u00ednea 39 <code>body.add(\"image\", new ByteArrayResource(...))</code>: Agrega la imagen cargada al cuerpo de la solicitud como un recurso de byte.</li> <li>L\u00ednea 42 <code>getFilename()</code>: Devuelve el nombre del archivo cargado.</li> <li>L\u00ednea 46 <code>HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity</code>: Crea la entidad HTTP que contiene tanto el cuerpo de la solicitud como los encabezados.</li> <li>L\u00ednea 49 <code>ResponseEntity&lt;String&gt; responseEntity</code>: Env\u00eda la solicitud POST al backend y recibe la respuesta.</li> <li>L\u00ednea 51 <code>if (responseEntity.getStatusCode().is2xxSuccessful()...)</code>: Verifica si la solicitud fue exitosa.</li> <li>L\u00ednea 52 <code>String imageUrl = responseEntity.getBody()</code>: Extrae la URL de la imagen generada de la respuesta.</li> <li>L\u00ednea 53 <code>imageDisplay.setSrc(imageUrl)</code>: Establece la URL como fuente de imageDisplay para mostrar la imagen.</li> <li>L\u00ednea 54 <code>descriptionArea.setValue(...)</code>: Muestra un mensaje en el \u00e1rea de texto, informando al usuario que se ha generado la caricatura.</li> <li>L\u00ednea 58 <code>catch (Exception e)</code>: Maneja cualquier excepci\u00f3n que ocurra durante el proceso de carga y muestra un mensaje de error al usuario.</li> <li>L\u00ednea 63 <code>add(...)</code>: Agrega los componentes de carga de imagen, \u00e1rea de descripci\u00f3n y visualizaci\u00f3n de imagen a la vista MultiModalityView.</li> </ul>"},{"location":"multimodality/#resumen","title":"Resumen","text":"<ul> <li>MultiModalityController: Procesar im\u00e1genes y generar una respuesta descriptiva, adem\u00e1s de producir una caricatura basada en esa descripci\u00f3n, demostrando el potencial de la IA multimodal para tareas de generaci\u00f3n de im\u00e1genes y an\u00e1lisis visual. Este controlador combina la capacidad de reconocimiento visual del modelo de chat con la generaci\u00f3n de contenido visual de DALL-E, proporcionando una experiencia completa de an\u00e1lisis e interacci\u00f3n con im\u00e1genes.</li> </ul>"},{"location":"tts-model/","title":"Text to Speech","text":""},{"location":"tts-model/#descripcion-del-tts-text-to-speech-en-openai-con-spring-ai","title":"Descripci\u00f3n del TTS (Text-to-Speech) en OpenAI con Spring AI","text":"<p>El uso de Text-to-Speech (TTS) en OpenAI, integrado con Spring AI, permite convertir texto a voz, generando archivos de audio a partir de mensajes escritos. Esta funcionalidad tiene un impacto significativo en aplicaciones donde la accesibilidad, la interacci\u00f3n con el usuario y la experiencia de usuario son esenciales. Con TTS, se pueden crear experiencias interactivas que benefician a usuarios con discapacidades visuales o aquellos que prefieren consumir informaci\u00f3n de manera auditiva.</p> <p>Al integrar OpenAI TTS con Spring AI, se obtiene:</p> <ul> <li>Accesibilidad Mejorada: Proporciona opciones de accesibilidad para usuarios que tienen dificultades para leer texto.</li> <li>Interacci\u00f3n Natural: Facilita experiencias m\u00e1s humanas y naturales en aplicaciones interactivas, como asistentes virtuales o chatbots, al permitir respuestas en formato de voz.</li> <li>Aplicaciones Multimedia: Aumenta el alcance de aplicaciones de entretenimiento, educaci\u00f3n y productividad que requieren elementos de voz generados autom\u00e1ticamente.</li> <li>Multimodalidad: Complementa otras modalidades de IA, como la generaci\u00f3n de texto o de im\u00e1genes, creando aplicaciones ricas en caracter\u00edsticas multimedia.</li> </ul> <p>Esta funcionalidad tambi\u00e9n simplifica el flujo de trabajo al automatizar la generaci\u00f3n de audios, eliminando la necesidad de grabaciones manuales y permitiendo respuestas r\u00e1pidas a mensajes personalizados. En conjunto, OpenAI y Spring AI facilitan la integraci\u00f3n de modelos avanzados de IA en aplicaciones Java de una manera escalable y eficiente, convirtiendo texto en audio con solo unos pocos pasos y logrando una experiencia de usuario mucho m\u00e1s envolvente y accesible.</p>"},{"location":"tts-model/#paso-1-controlador-ttscontroller","title":"Paso 1: Controlador TtsController","text":"<p>Este controlador recibe un mensaje de texto como entrada y devuelve un archivo de audio MP3 generado a partir del mensaje.</p> TtsController.java<pre><code>@RestController\n@RequestMapping(\"/tts\")\n@RequiredArgsConstructor\npublic class TtsController {\n\n    private final OpenAiAudioSpeechModel openAiAudioSpeechModel;\n\n    @GetMapping(produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)\n    public ResponseEntity&lt;byte[]&gt; tts(@RequestParam(\"message\") String message) throws Exception {\n        OpenAiAudioSpeechOptions speechOptions = OpenAiAudioSpeechOptions.builder()\n                .withResponseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat.MP3)\n                .withVoice(OpenAiAudioApi.SpeechRequest.Voice.NOVA)\n                .withSpeed(1.0f)\n                .withModel(OpenAiAudioApi.TtsModel.TTS_1_HD.value)\n                .build();\n\n        SpeechPrompt prompt = new SpeechPrompt(message, speechOptions);\n        SpeechResponse response = openAiAudioSpeechModel.call(prompt);\n\n        byte[] responseBytes = response.getResult().getOutput();\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"tts_audio.mp3\\\"\")\n                .body(responseBytes);\n    }\n\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>@RestController</code>: Indica que esta clase es un controlador REST en Spring, lo que significa que sus m\u00e9todos manejar\u00e1n solicitudes HTTP y devolver\u00e1n datos directamente en el cuerpo de la respuesta.</li> <li>L\u00ednea 2 <code>@RequestMapping(\"/tts\")</code>: Define el endpoint base para este controlador, que en este caso ser\u00e1 /tts.</li> <li>L\u00ednea 3 <code>@RequiredArgsConstructor</code>: Genera un constructor con los atributos finales (final), permitiendo la inyecci\u00f3n de dependencias de manera autom\u00e1tica.</li> <li>L\u00ednea 6 Se inyecta <code>OpenAiAudioSpeechModel</code>, una clase que maneja la interacci\u00f3n con el modelo de texto a voz de OpenAI.</li> <li>L\u00ednea 8 <code>@GetMapping(produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)</code>: Define un endpoint de tipo GET que devuelve datos binarios (audio en formato MP3).</li> <li>L\u00ednea 9 <code>@RequestParam(\"message\") String message</code>: El par\u00e1metro message captura el texto que ser\u00e1 convertido a voz.</li> </ul> <pre><code>OpenAiAudioSpeechOptions speechOptions = OpenAiAudioSpeechOptions.builder()\n        .withResponseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat.MP3)\n        .withVoice(OpenAiAudioApi.SpeechRequest.Voice.NOVA)\n        .withSpeed(1.0f)\n        .withModel(OpenAiAudioApi.TtsModel.TTS_1_HD.value)\n        .build();\n</code></pre> <ul> <li> <p>L\u00edneas 10-14 Configura las opciones para el modelo de texto a voz, incluyendo:</p> <ul> <li>Formato de respuesta en MP3.</li> <li>Voz seleccionada (<code>NOVA</code>).</li> <li>Velocidad de reproducci\u00f3n.</li> <li>Modelo espec\u00edfico de OpenAI para la s\u00edntesis de voz.</li> </ul> </li> <li> <p>L\u00ednea 17 <code>SpeechPrompt</code>: Construye el mensaje que se enviar\u00e1 al modelo de texto a voz junto con las opciones configuradas.</p> </li> <li>L\u00ednea 18 <code>penAiAudioSpeechModel.call(prompt)</code>: Realiza la llamada al modelo para obtener la respuesta de voz generada.</li> </ul> <pre><code>byte[] responseBytes = response.getResult().getOutput();\n</code></pre> <ul> <li> <p>Extrae el contenido de audio generado en forma de arreglo de bytes.</p> </li> <li> <p>L\u00ednea 22 <code>ResponseEntity</code>: Devuelve la respuesta HTTP, estableciendo el tipo de contenido como <code>APPLICATION_OCTET_STREAM</code> y adjuntando el archivo con el nombre <code>tts_audio.mp3</code>.</p> </li> <li>L\u00ednea 25 <code>responseBytes</code> contiene el archivo MP3 que se genera a partir del texto.</li> </ul>"},{"location":"tts-model/#paso-2-integracion-en-vaadin-tts","title":"Paso 2: Integraci\u00f3n en Vaadin <code>TTS</code>","text":"<p>Como se puede observar en la figura #1 esta vista permite al usuario introducir un mensaje de texto, convertirlo a voz y reproducir el audio generado directamente en la interfaz.</p> <p></p> TtsController.java<pre><code>@Route(\"text-to-speech\")\n@Menu(title = \"Text to Speech\", order = 5)\npublic class TtsView extends VerticalLayout {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n    private final String backendUrl = \"http://localhost:8080/tts\";\n\n    public TtsView() {\n        setSizeFull();\n\n        TextArea messageInput = new TextArea(\"Enter the message to convert to speech:\");\n        messageInput.setWidth(\"400px\");\n\n        Button generateAudioButton = new Button(\"Generate Audio\");\n\n        // Placeholder for audio player\n        HtmlComponent audioPlayer = new HtmlComponent(\"audio\");\n        audioPlayer.getElement().setAttribute(\"controls\", true);\n\n        generateAudioButton.addClickListener(click -&gt; {\n            String message = messageInput.getValue();\n            String url = backendUrl + \"?message=\" + message;\n\n            try {\n                ResponseEntity&lt;byte[]&gt; responseEntity = restTemplate.exchange(\n                        url,\n                        org.springframework.http.HttpMethod.GET,\n                        null,\n                        byte[].class\n                );\n\n                if (responseEntity.getStatusCode().is2xxSuccessful() &amp;&amp; responseEntity.getBody() != null) {\n                    StreamResource streamResource = new StreamResource(\"tts_audio.mp3\", () -&gt;\n                            new ByteArrayInputStream(responseEntity.getBody()));\n                    audioPlayer.getElement().setAttribute(\"src\", streamResource);\n                } else {\n                    Notification.show(\"Error: Failed to generate audio.\");\n                }\n            } catch (Exception e) {\n                Notification.show(\"Error: \" + e.getMessage());\n            }\n        });\n\n        add(messageInput, generateAudioButton, audioPlayer);\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1 <code>@Route(\"text-to-speech\")</code>: Define la URL de acceso para esta vista en Vaadin.</li> <li>L\u00ednea 2 <code>@Menu</code>: Etiqueta personalizada para integrar la vista en el men\u00fa.</li> <li> <p>L\u00ednea 3 <code>VerticalLayout</code>: Utiliza un layout vertical para organizar los componentes.</p> </li> <li> <p>L\u00ednea 5 <code>RestTemplate</code>: Cliente HTTP que realiza llamadas al backend.</p> </li> <li> <p>L\u00ednea 6 <code>backendUrl</code>: Define la URL del endpoint del backend que genera el audio a partir de texto.</p> </li> <li> <p>L\u00ednea 7 <code>setSizeFull()</code>: Ajusta el layout para ocupar todo el espacio disponible.</p> </li> <li> <p>L\u00ednea 11 <code>TextArea messageInput</code>: \u00c1rea de texto donde el usuario ingresa el mensaje a convertir.</p> </li> <li> <p>L\u00ednea 12 <code>setWidth(\"400px\")</code>: Define el ancho del \u00e1rea de texto.</p> </li> <li> <p>L\u00ednea 14 <code>Button generateAudioButton</code>: Bot\u00f3n que inicia el proceso de generaci\u00f3n de audio al hacer clic.</p> </li> <li> <p>L\u00ednea 17 <code>HtmlComponent audioPlayer</code>: Componente HTML para reproducir el archivo de audio generado.</p> </li> <li> <p>L\u00ednea 18 <code>setAttribute(\"controls\", true)</code>: A\u00f1ade controles de reproducci\u00f3n como play, pause y volumen al componente de audio.</p> </li> <li> <p>L\u00ednea 20 <code>generateAudioButton.addClickListener</code>: Asigna una acci\u00f3n al bot\u00f3n para enviar el mensaje al backend.</p> </li> <li> <p>L\u00ednea 22 Construye la URL para hacer la solicitud GET al backend, incluyendo el mensaje como par\u00e1metro.</p> </li> <li> <p>L\u00ednea 25 <code>restTemplate.exchange</code>: Realiza la solicitud HTTP GET al backend y espera un arreglo de bytes como respuesta (el audio en MP3).</p> </li> <li> <p>L\u00ednea 32 Verifica si la solicitud fue exitosa y si contiene datos.</p> </li> <li> <p>L\u00ednea 33 Crea un <code>StreamResource</code> a partir de los bytes de audio recibidos y establece la fuente del <code>audioPlayer</code> con este recurso para que pueda reproducirse.</p> </li> <li> <p>L\u00ednea 37 Muestra una notificaci\u00f3n de error si falla la generaci\u00f3n del audio o si ocurre una excepci\u00f3n.</p> </li> <li> <p>L\u00ednea 44 A\u00f1ade los componentes al layout en el orden deseado para que se muestren en la vista.</p> </li> </ul>"},{"location":"tts-model/#resumen","title":"Resumen","text":"<p>La funcionalidad de Text-to-Speech (TTS) integrada en el proyecto permite convertir texto en audio usando OpenAI y Spring AI. Esta funcionalidad, que emplea el modelo de voz de OpenAI, toma un mensaje de texto proporcionado por el usuario, lo procesa a trav\u00e9s del modelo de TTS de OpenAI y devuelve un archivo de audio en formato MP3 que representa el mensaje hablado.</p>"}]}